is.null(factor_cols)
length(factor_cols)
if(length(factor_cols)){print("hello world")}
if(length(factor_cols) == 0){print("hello world")}
if(length(factor_cols) == 1){print("hello world")}
if(1){print("hello world")}
if(){print("hello world")}
if(0){print("hello world")}
if(2){print("hello world")}
devtools::document()
devtools::document(/drpop)
devtools::document("C:/manja/OneDrive/Documents/drpop")
devtools::document("C:/Users/manja/OneDrive/Documents/drpop")
devtools::document("C:/Users/manja/OneDrive/Documents/drpop/")
devtools::document()
devtools::document()
devtools::document()
devtools::documet()
devtools::document()
devtools::document()
devtools::document()
x = matrix(rnorm(n*3, 2, 1), nrow = n)
n = 5000
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
ss = sample(c('a','b','c','d','e','f'), nrow(datacrc), replace = TRUE, prob = (1:6)/sum(1:6))
datacrc1 = data.frame(datacrc, ss)
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')
library(drpop)
n = 5000
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
ss = sample(c('a','b','c','d','e','f'), nrow(datacrc), replace = TRUE, prob = (1:6)/sum(1:6))
datacrc1 = data.frame(datacrc, ss)
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')
library(drpop)
n = 100
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
ss = sample(c('a','b','c','d','e','f'), nrow(datacrc), replace = TRUE, prob = (1:6)/sum(1:6))
datacrc1 = data.frame(datacrc, ss)
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')
n = 1000
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
p = psinhat(List_matrix = datacrc, funcname = c("logit", "gam", "sl"))
plot(psinhat = p)
plot(psinhat = p)$g1
ss = sample(c('a','b','c','d','e','f'), nrow(datacrc), replace = TRUE, prob = (1:6)/sum(1:6))
datacrc1 = data.frame(datacrc, ss)
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')
traceback()
List_matr
List_matrix = datacrc1
K = 2; filterrows = TRUE; funcname = c("logit")
condvar = "ss"
nfolds = 2
eps = 0.005
iter = 50
l = ncol(List_matrix) - K
n = nrow(List_matrix)
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
condvar_vec = unique(List_matrix[,condvar + K])
if(is.character(condvar)){
condvar = which(colnames(List_matrix) == condvar) - K
}
condvar_vec = unique(List_matrix[,condvar + K])
psi = numeric(0)
sigma2 = numeric(0)
n = numeric(0)
varn = numeric(0)
N = numeric(0)
cin.l = numeric(0)
cin.u = numeric(0)
condvar_vec
cvar = "e"
List_matrixsub = List_matrix[List_matrix[,K + condvar] == cvar, -c(K + condvar)]
est = try(psinhat(List_matrix = List_matrixsub, K = K, filterrows = filterrows, funcname = funcname, nfolds = 2, twolist = twolist, eps = eps, iter = iter, sl.lib = sl.lib), silent = TRUE)
class(est)
names(est)
est$psi
psi = rbind(psi, data.frame(listpair = rownames(est$psi), est$psi, condvar = cvar), make.row.names = FALSE)
sigma2 = rbind(sigma2, data.frame(listpair = rownames(est$psi), est$sigma2, condvar = cvar), make.row.names = FALSE)
n = rbind(n, data.frame(listpair = rownames(est$psi), est$n, condvar = cvar), make.row.names = FALSE)
varn = rbind(varn, data.frame(listpair = rownames(est$psi), est$varn, condvar = cvar), make.row.names = FALSE)
N = rbind(N, data.frame(N = est$N, condvar = cvar))
cin.l = rbind(cin.l, data.frame(listpair = rownames(est$psi), est$cin.l, condvar = cvar), make.row.names = FALSE)
cin.l
data.frame(listpair = rownames(est$psi), est$cin.l, condvar = cvar), make.row.names = FALSE)
data.frame(listpair = rownames(est$psi), est$cin.l, condvar = cvar)
rownames(est4psi)
rownames(est$psi)
est$cin.l
est
est$cin.l
est$cin.l = N
est$cin.l
N
#' data = matrix(sample(c(0,1), 2000, replace = TRUE), ncol = 2)
#' x = matrix(rnorm(nrow(data)*3, 2,1), nrow = nrow(data))
#'
#' psin_estimate = psinhat(List_matrix = data)
#' #this returns the basic plug-in estimate since covariates are absent.
#'
#' data = cbind(data, x)
#' psin_estimate = psinhat(List_matrix = data, funcname = c("logit", "sl"), nfolds = 2, twolist = FALSE, eps = 0.005)
#' #this returns the plug-in, the bias-corrected and the tmle estimate for the two models
#' @export
psinhat <- function(List_matrix, K = 2, filterrows = TRUE, funcname = c("logit"), nfolds = 5, twolist = FALSE, eps = 0.005, iter = 50, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
stopifnot(informat(List_matrix = List_matrix, K = K))
List_matrix = na.omit(List_matrix)
if(filterrows){
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
}
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
stopifnot(N > 1)
if (l >= 0 & N < 500){
l = 0
warning(cat("Insufficient number of observations for doubly-robust estimation."))
}
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
stop("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
Message(cat("Lists ", which(conforminglists == FALSE), " are not in the required format."))
}
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 1)
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ",", s, sep = ''))
})}))
colnames(psiinv_summary) =  c("PI")
var_summary = psiinv_summary
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
next
}
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
psiinv_summary[paste(i, ",", j, sep = ''),] = q1*q2/q12
var_summary[paste(i, ",", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
ifvals = NULL
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
cin.l = pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N),
cin.u = N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
}else{
#converting factor columns to numeric
List_matrix = reformat(List_matrix)
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
if(nfolds > 1 & nfolds > N/50) {
nfolds = pmax(floor(N/50), 1)
cat("nfolds is reduced to ", nfolds, " to have sufficient training data.\n")
}
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ",", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
var_summary = psiinv_summary
ifvals = matrix(NA, nrow = N*K*(K-1)/2, ncol = length(funcname))
colnames(ifvals) = funcname
rownames(ifvals) = rep(rownames(psiinv_summary), each = N)
nuis = matrix(NA, nrow = N*K*(K-1)/2, ncol = 3*length(funcname))
colnames(nuis) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
rownames(nuis) = rownames(ifvals)
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
varmat = psiinvmat
ifvalsfold = matrix(NA, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(NA, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List.train = List1, List.test = List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhat.dr = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhat.dr)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat.tmle = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat.tmle
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat.tmle
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ",", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ",", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
ifvals[rownames(ifvals) == paste(i, ",", j, sep = ''),] = ifvalsfold
nuis[rownames(nuis) == paste(i, ",", j, sep = ''),] = nuisfold
nuistmle[rownames(nuistmle) == paste(i, ",", j, sep = ''),] = nuistmlefold
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
ifvals = ifvals, nuis = nuis, nuistmle = nuistmle,
cin.l = pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N),
cin.u = N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
}
}
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')
devtoold::install_github("mqnjqrid/drpop")
devtools::install_github("mqnjqrid/drpop")
detach("package:dplyr", unload = TRUE)
remove.packages("drpop", lib="~/R/win-library/4.0")
devtools::install_github("mqnjqrid/drpop")
drpop::psinhat
library(drpop)
drpop::psinhat
#' data = matrix(sample(c(0,1), 2000, replace = TRUE), ncol = 2)
#' x = matrix(rnorm(nrow(data)*3, 2,1), nrow = nrow(data))
#'
#' psin_estimate = psinhat(List_matrix = data)
#' #this returns the basic plug-in estimate since covariates are absent.
#'
#' data = cbind(data, x)
#' psin_estimate = psinhat(List_matrix = data, funcname = c("logit", "sl"), nfolds = 2, twolist = FALSE, eps = 0.005)
#' #this returns the plug-in, the bias-corrected and the tmle estimate for the two models
#' @export
psinhat <- function(List_matrix, K = 2, filterrows = TRUE, funcname = c("logit"), nfolds = 5, twolist = FALSE, eps = 0.005, iter = 50, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
stopifnot(informat(List_matrix = List_matrix, K = K))
List_matrix = na.omit(List_matrix)
if(filterrows){
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
}
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
stopifnot(N > 1)
if (l >= 0 & N < 500){
l = 0
warning(cat("Insufficient number of observations for doubly-robust estimation."))
}
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
stop("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
Message(cat("Lists ", which(conforminglists == FALSE), " are not in the required format."))
}
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 1)
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ",", s, sep = ''))
})}))
colnames(psiinv_summary) =  c("PI")
var_summary = psiinv_summary
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
next
}
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
psiinv_summary[paste(i, ",", j, sep = ''),] = q1*q2/q12
var_summary[paste(i, ",", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
ifvals = NULL
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
cin.l = pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N),
cin.u = N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
}else{
#converting factor columns to numeric
List_matrix = reformat(List_matrix)
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
if(nfolds > 1 & nfolds > N/50) {
nfolds = pmax(floor(N/50), 1)
cat("nfolds is reduced to ", nfolds, " to have sufficient training data.\n")
}
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ",", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
var_summary = psiinv_summary
ifvals = matrix(NA, nrow = N*K*(K-1)/2, ncol = length(funcname))
colnames(ifvals) = funcname
rownames(ifvals) = rep(rownames(psiinv_summary), each = N)
nuis = matrix(NA, nrow = N*K*(K-1)/2, ncol = 3*length(funcname))
colnames(nuis) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
rownames(nuis) = rownames(ifvals)
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
varmat = psiinvmat
ifvalsfold = matrix(NA, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(NA, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List.train = List1, List.test = List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhat.dr = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhat.dr)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat.tmle = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat.tmle
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat.tmle
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ",", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ",", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
ifvals[rownames(ifvals) == paste(i, ",", j, sep = ''),] = ifvalsfold
nuis[rownames(nuis) == paste(i, ",", j, sep = ''),] = nuisfold
nuistmle[rownames(nuistmle) == paste(i, ",", j, sep = ''),] = nuistmlefold
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
ifvals = ifvals, nuis = nuis, nuistmle = nuistmle,
cin.l = pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N),
cin.u = N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
}
}
est = try(psinhat(List_matrix = List_matrixsub, K = K, filterrows = filterrows, funcname = funcname, nfolds = 2, twolist = twolist, eps = eps, iter = iter, sl.lib = sl.lib), silent = TRUE)
est
psi = rbind(psi, data.frame(listpair = rownames(est$psi), est$psi, condvar = cvar), make.row.names = FALSE)
sigma2 = rbind(sigma2, data.frame(listpair = rownames(est$psi), est$sigma2, condvar = cvar), make.row.names = FALSE)
n = rbind(n, data.frame(listpair = rownames(est$psi), est$n, condvar = cvar), make.row.names = FALSE)
varn = rbind(varn, data.frame(listpair = rownames(est$psi), est$varn, condvar = cvar), make.row.names = FALSE)
N = rbind(N, data.frame(N = est$N, condvar = cvar))
cin.l = rbind(cin.l, data.frame(listpair = rownames(est$psi), est$cin.l, condvar = cvar), make.row.names = FALSE)
cin.u = rbind(cin.u, data.frame(listpair = rownames(est$psi), est$cin.u, condvar = cvar), make.row.names = FALSE)
p = psinhatcond(List_matrix = datacrc1, condvar = 'ss')

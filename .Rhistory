colnames(ifvals) = funcname
nuis = matrix(0, nrow = N, ncol = 3*length(funcname))
colnames(nuis) = paste(c("q12", "q1", "q2"), rep(funcname, each = 3))
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuis[sbset, paste(c("q12", "q1", "q2"), func)] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvals[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhatq)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmle[sbset, paste(c("q12", "q1", "q2"), func)] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ", ", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ", ", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
ifvals = ifvals, nuis = nuis, nuistmle = nuistmle,
cin.l = N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)),
cin.u = N*psiinv_summary + 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
}
}
estim <- psinhat(List_matrix = data, func = c("logit"), nfolds = 2, K = 2)
names(estim)
estim$cin.l
estim$cin.u
estim$nuis
dim(estim$nuis)
head(estim$nuis)
estim <- psinhat(List_matrix = data, func = c("logit", "gam"), nfolds = 2, K = 2)
head(estim$nuis)
head(estim$nuistmle)
estim$cin.l
estim$cin.u
devtools::document()
estim$inf
head(estim$ifvals)
estim <- psinhat(List_matrix = cbind(data[,1], data), func = c("logit", "gam"), nfolds = 2, K = 2)
head(data[,1])
estim <- psinhat(List_matrix = cbind(data[,1], data), func = c("logit", "gam"), nfolds = 2, K = 3)
traceback()
devtools::document()
summary(data)
condv = sample(nrow(data), 1:6, replace = TRUE)), data = cbind(data, condv)
condv = sample(nrow(data), 1:6, replace = TRUE), data = cbind(data, condv)
condv = sample(nrow(data), 1:6, replace = TRUE); data = cbind(data, condv)
head(data)
List_matrix = data
funcname
funcname = c("logit", "sl")
K = 3
nfolds = 2
condvar = "condv"
twolist = TRUE
eps = 0.005; iter = 100
sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
condvar = which(colnames(List_matrix) == condvar) - K
condvar
K
head(List_matrix)
K = 2
List_matrix = data
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
condvar = which(colnames(List_matrix) == condvar) - K
condvar
condvar = "condv"
condvar = which(colnames(List_matrix) == condvar) - K
condvar
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ", ", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
var_summary = psiinv_summary
ifvals = matrix(0, nrow = N*K*(K-1)/2, ncol = length(funcname))
colnames(ifvals) = funcname
rownames(ifvals) = rep(rownames(psiinv_summary), each = N)
nuis = matrix(0, nrow = N*K*(K-1)/2, ncol = 3*length(funcname))
colnames(nuis) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
rownames(nuis) = rownames(ifvals)
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
ifvalsfold = matrix(0, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(0, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(c("q12", "q1", "q2"), func)] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhatq)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(c("q12", "q1", "q2"), func)] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ", ", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ", ", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
ifvals[paste(i, ", ", j, sep = ''),] = ifvalsfold
nuis[paste(i, ", ", j, sep = ''),] = nuisfold
nuistmle[paste(i, ", ", j, sep = ''),] = nuistmlefold
}
}
i
j
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
ifvalsfold = matrix(0, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(0, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
nuistmlefold = nuisfold
folds
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
func
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
class(qhat)
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(c("q12", "q1", "q2"), func)] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ", ", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
var_summary = psiinv_summary
ifvals = matrix(0, nrow = N*K*(K-1)/2, ncol = length(funcname))
colnames(ifvals) = funcname
rownames(ifvals) = rep(rownames(psiinv_summary), each = N)
nuis = matrix(0, nrow = N*K*(K-1)/2, ncol = 3*length(funcname))
colnames(nuis) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
rownames(nuis) = rownames(ifvals)
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
ifvalsfold = matrix(0, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(0, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"))] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhatq)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"))] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ", ", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ", ", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
ifvals[paste(i, ", ", j, sep = ''),] = ifvalsfold
nuis[paste(i, ", ", j, sep = ''),] = nuisfold
nuistmle[paste(i, ", ", j, sep = ''),] = nuistmlefold
}
}
dim(ifvalsfold)
folds
dim(ifvals[paste(i, ", ", j, sep = ''),])
dim(ifvals)
head(rownames(ifvals))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ", ", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
var_summary = psiinv_summary
ifvals = matrix(0, nrow = N*K*(K-1)/2, ncol = length(funcname))
colnames(ifvals) = funcname
rownames(ifvals) = rep(rownames(psiinv_summary), each = N)
nuis = matrix(0, nrow = N*K*(K-1)/2, ncol = 3*length(funcname))
colnames(nuis) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
rownames(nuis) = rownames(ifvals)
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
ifvalsfold = matrix(0, nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(0, nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"))
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps, sl.lib = sl.lib), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"))] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhatq)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"))] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ", ", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ", ", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
ifvals[rownames(ifvals) == paste(i, ", ", j, sep = ''),] = ifvalsfold
nuis[rownames(nuis) == paste(i, ", ", j, sep = ''),] = nuisfold
nuistmle[rownames(nuistmle) == paste(i, ", ", j, sep = ''),] = nuistmlefold
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary, n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1), N = N,
ifvals = ifvals, nuis = nuis, nuistmle = nuistmle,
cin.l = N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)),
cin.u = N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))
))
head(nuis)
devtools::document()
rm(list = c("tmle"))
devtools::document()
?is.element

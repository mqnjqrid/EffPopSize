for(alp in 1:length(alpha_vec)) {
alpha = alpha_vec[alp]
for(sig in 1:length(sigma_vec)){print(c(n0, alp, sig))
sigma = sigma_vec[sig]
K = 2;l = 1
for (s in 1:simuldraw){print(s)
datap = dat_p(n, l)
List_matrix = datap$List_matrix
N = sum(pmax(List_matrix[,1], List_matrix[,2]))
est_val = psinhat_simul(List_matrix, n = n0, K = 2, sigma = sigma, alpha = alpha, twolist = TRUE, eps = 0.005, nfolds = 2)
datorg = rbind(datorg, cbind(est_val$psi, alpha, sigma, n0))
varorg = rbind(varorg, cbind(est_val$sigma2/N, alpha, sigma, n0))
norg = rbind(norg, cbind(est_val$n, alpha, sigma, n0))
varnorg = rbind(varnorg, cbind(est_val$varn, alpha, sigma, n0))
}
beep(sound = 10)
}
}
datap = dat_p(n, l)
List_matrix = datap$List_matrix
N = sum(pmax(List_matrix[,1], List_matrix[,2]))
est_val = psinhat_simul(List_matrix, n = n0, K = 2, sigma = sigma, alpha = alpha, twolist = TRUE, eps = 0.005, nfolds = 2)
datorg = rbind(datorg, cbind(est_val$psi, alpha, sigma, n0))
varorg = rbind(varorg, cbind(est_val$sigma2/N, alpha, sigma, n0))
norg = rbind(norg, cbind(est_val$n, alpha, sigma, n0))
varnorg = rbind(varnorg, cbind(est_val$varn, alpha, sigma, n0))
datorg = numeric(0)
varorg = datorg
norg = datorg
varnorg = datorg
ti = 1
psi0 =  dat_p(n0, l)$psi0
set.seed(1)
for(alp in 1:length(alpha_vec)) {
alpha = alpha_vec[alp]
for(sig in 1:length(sigma_vec)){print(c(n0, alp, sig))
sigma = sigma_vec[sig]
K = 2;l = 1
for (s in 1:simuldraw){print(s)
datap = dat_p(n, l)
List_matrix = datap$List_matrix
N = sum(pmax(List_matrix[,1], List_matrix[,2]))
est_val = psinhat_simul(List_matrix, n = n0, K = 2, sigma = sigma, alpha = alpha, twolist = TRUE, eps = 0.005, nfolds = 2)
datorg = rbind(datorg, cbind(est_val$psi, alpha, sigma, n0))
varorg = rbind(varorg, cbind(est_val$sigma2/N, alpha, sigma, n0))
norg = rbind(norg, cbind(est_val$n, alpha, sigma, n0))
varnorg = rbind(varnorg, cbind(est_val$varn, alpha, sigma, n0))
}
beep(sound = 10)
}
}
datorg = data.frame(datorg)
datorg = melt(datorg, id.vars = c("alpha", "sigma", "n0"), value.name = "psi", variable.name = "model")
varorg = data.frame(varorg)
varorg = melt(varorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varpsi", variable.name = "model")
norg = data.frame(norg)
norg = melt(norg, id.vars = c("alpha", "sigma", "n0"), value.name = "n", variable.name = "model")
varnorg = data.frame(varnorg)
varnorg = melt(varnorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varn", variable.name = "model")
psidata = merge(datorg, varorg, by = c("model", 'alpha', 'sigma', "n0"))
psidata$alpha = as.numeric(as.character(psidata$alpha))
psidata$sigma = as.numeric(as.character(psidata$sigma))
psidata$psi0 = psi0
ndata = merge(norg, varnorg, by = c('model', 'alpha', 'sigma', "n0"))
ndata$alpha = as.numeric(as.character(ndata$alpha))
ndata$sigma = as.numeric(as.character(ndata$sigma))
################### Plots for psi as capture probability
dat_pibctr_summary = ddply(psidata, c("alpha", "sigma", "n0", "model"), summarise,
mean = mean(abs(psi - psi0)),
rmse = sqrt(mean((psi - psi0)^2)),
sd = sqrt(var(psi))
)
dat_pibctr_summary$coverage = NA
############## manually calculating coverage due to error on line 211-212
for(alpha in alpha_vec){
for(sigma in sigma_vec){
for(model in unique(dat_pibctr_summary$model)){
subdat = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
dat_pibctr_summary[dat_pibctr_summary$n0 == n0 & dat_pibctr_summary$alpha == alpha &
dat_pibctr_summary$sigma == sigma & dat_pibctr_summary$model == model,
]$coverage = mean(abs(subdat$n0 - subdat$n) <= sqrt(subdat$varn)*1.95, na.rm = TRUE)
}
}
}
dat_pibctr_summary$coverage = 1 - dat_pibctr_summary$coverage
tsize = 16
gbasic = ggplot(data = dat_pibctr_summary, aes(x = factor(model), fill = factor(model))) +
theme_bw() +
theme(text = element_text(size = tsize), axis.text.x = element_blank(), axis.ticks.x=element_blank(), axis.title.x=element_blank(), legend.position = "bottom") +
facet_grid(sigma ~ alpha, labeller = label_both, scales = "free_y") +
#scale_fill_manual("Estimation method", values=c("red", "#E69F00", "#56B4E9", "gray")) +
scale_fill_grey(start = 0, end = 1)
v1 = gbasic +
geom_bar(mapping =  aes(y = mean), stat = "identity", color = "black") +
labs(fill = "method", title = substitute(paste("Bias of ", psi, ', ', psi, ' = ', var), list(var = round(psi0, 1))), x = NULL, y = NULL)
v2 = gbasic +
geom_bar(mapping = aes(y = rmse), stat = "identity", color = "black") +
labs(fill = "method", title = expression(paste("RMSE of ", psi)), x = NULL, y = NULL)
v3 = gbasic +
geom_bar(mapping =  aes(y = coverage), stat = "identity", color = "black") +
labs(fill = "method", title = "1 - coverage", x = NULL, y = NULL)
#pdf(paste("C:/Users/manja/Dropbox/capture_recapture/codes/images/crc_simulated_barplots/barplottheta_K2_l1_psi0", round(10*psi0), "0_alpha_sigma12_bias_rmse_cvrg.pdf", sep = ''), width = 1100/100 + length(alpha_vec - 3)*0.75, height = 400/100, onefile = FALSE) #height = 375 and 415
ggarrange(v1, v2, v3, ncol = 3, common.legend = TRUE, legend = "bottom")
dat_pibctr_summary$coverage = NA
############## manually calculating coverage due to error on line 211-212
for(alpha in alpha_vec){
for(sigma in sigma_vec){
for(model in unique(dat_pibctr_summary$model)){
subdat = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
dat_pibctr_summary[dat_pibctr_summary$n0 == n0 & dat_pibctr_summary$alpha == alpha &
dat_pibctr_summary$sigma == sigma & dat_pibctr_summary$model == model,
]$coverage = mean(abs(subdat$n0 - subdat$n) <= sqrt(subdat$varn)*1.95, na.rm = TRUE)
}
}
}
dat_pibctr_summary$coverage = 1 - dat_pibctr_summary$coverage
tsize = 16
gbasic = ggplot(data = dat_pibctr_summary, aes(x = factor(model), fill = factor(model))) +
theme_bw() +
theme(text = element_text(size = tsize), axis.text.x = element_blank(), axis.ticks.x=element_blank(), axis.title.x=element_blank(), legend.position = "bottom") +
facet_grid(sigma ~ alpha, labeller = label_both, scales = "free_y") +
#scale_fill_manual("Estimation method", values=c("red", "#E69F00", "#56B4E9", "gray")) +
scale_fill_grey(start = 0, end = 1)
v1 = gbasic +
geom_bar(mapping =  aes(y = mean), stat = "identity", color = "black") +
labs(fill = "method", title = substitute(paste("Bias of ", psi, ', ', psi, ' = ', var), list(var = round(psi0, 1))), x = NULL, y = NULL)
v2 = gbasic +
geom_bar(mapping = aes(y = rmse), stat = "identity", color = "black") +
labs(fill = "method", title = expression(paste("RMSE of ", psi)), x = NULL, y = NULL)
v3 = gbasic +
geom_bar(mapping =  aes(y = coverage), stat = "identity", color = "black") +
labs(fill = "method", title = "1 - coverage", x = NULL, y = NULL)
#pdf(paste("C:/Users/manja/Dropbox/capture_recapture/codes/images/crc_simulated_barplots/barplottheta_K2_l1_psi0", round(10*psi0), "0_alpha_sigma12_bias_rmse_cvrg.pdf", sep = ''), width = 1100/100 + length(alpha_vec - 3)*0.75, height = 400/100, onefile = FALSE) #height = 375 and 415
ggarrange(v1, v2, v3, ncol = 3, common.legend = TRUE, legend = "bottom")
alpha
sigma
sigma = 0.5
model
n0
subdat = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
summary(abs(subdat$n0 - subdat$n) <= sqrt(subdat$varn)*1.95)
summary(subdat$n0)
summary(subdat$n)
subdatpsi = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
subdatpsi$psi
head(subdatpsi)
subdatpsi = psidata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
head(subdatpsi)
N
n0 = 1000; l = 1
source("C:/Users/manja/Dropbox/capture_recapture/codes/cond_indep_pair/indep_cov_Tilling_simulation.R")
simuldraw = 50
alpha_vec = c(0.1, 0.25, 0.5)#, 0.2, 0.15, 0.1)
sigma_vec = c(0.5, 1)
datorg = numeric(0)
varorg = datorg
norg = datorg
varnorg = datorg
ti = 1
psi0 =  dat_p(n0, l)$psi0
set.seed(1)
for(alp in 1:length(alpha_vec)) {
alpha = alpha_vec[alp]
for(sig in 1:length(sigma_vec)){print(c(n0, alp, sig))
sigma = sigma_vec[sig]
K = 2;l = 1
for (s in 1:simuldraw){print(s)
datap = dat_p(n0, l)
List_matrix = datap$List_matrix
N = sum(pmax(List_matrix[,1], List_matrix[,2]))
est_val = psinhat_simul(List_matrix, n = n0, K = 2, sigma = sigma, alpha = alpha, twolist = TRUE, eps = 0.005, nfolds = 2)
datorg = rbind(datorg, cbind(est_val$psi, alpha, sigma, n0))
varorg = rbind(varorg, cbind(est_val$sigma2/N, alpha, sigma, n0))
norg = rbind(norg, cbind(est_val$n, alpha, sigma, n0))
varnorg = rbind(varnorg, cbind(est_val$varn, alpha, sigma, n0))
}
beep(sound = 10)
}
}
datorg = data.frame(datorg)
datorg = melt(datorg, id.vars = c("alpha", "sigma", "n0"), value.name = "psi", variable.name = "model")
varorg = data.frame(varorg)
varorg = melt(varorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varpsi", variable.name = "model")
norg = data.frame(norg)
norg = melt(norg, id.vars = c("alpha", "sigma", "n0"), value.name = "n", variable.name = "model")
varnorg = data.frame(varnorg)
varnorg = melt(varnorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varn", variable.name = "model")
psidata = merge(datorg, varorg, by = c("model", 'alpha', 'sigma', "n0"))
psidata$alpha = as.numeric(as.character(psidata$alpha))
psidata$sigma = as.numeric(as.character(psidata$sigma))
psidata$psi0 = psi0
ndata = merge(norg, varnorg, by = c('model', 'alpha', 'sigma', "n0"))
ndata$alpha = as.numeric(as.character(ndata$alpha))
ndata$sigma = as.numeric(as.character(ndata$sigma))
################### Plots for psi as capture probability
dat_pibctr_summary = ddply(psidata, c("alpha", "sigma", "n0", "model"), summarise,
mean = mean(abs(psi - psi0)),
rmse = sqrt(mean((psi - psi0)^2)),
sd = sqrt(var(psi))
)
dat_pibctr_summary$coverage = NA
############## manually calculating coverage due to error on line 211-212
for(alpha in alpha_vec){
for(sigma in sigma_vec){
for(model in unique(dat_pibctr_summary$model)){
subdat = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
dat_pibctr_summary[dat_pibctr_summary$n0 == n0 & dat_pibctr_summary$alpha == alpha &
dat_pibctr_summary$sigma == sigma & dat_pibctr_summary$model == model,
]$coverage = mean(abs(subdat$n0 - subdat$n) <= sqrt(subdat$varn)*1.95, na.rm = TRUE)
}
}
}
dat_pibctr_summary$coverage = 1 - dat_pibctr_summary$coverage
tsize = 16
gbasic = ggplot(data = dat_pibctr_summary, aes(x = factor(model), fill = factor(model))) +
theme_bw() +
theme(text = element_text(size = tsize), axis.text.x = element_blank(), axis.ticks.x=element_blank(), axis.title.x=element_blank(), legend.position = "bottom") +
facet_grid(sigma ~ alpha, labeller = label_both, scales = "free_y") +
#scale_fill_manual("Estimation method", values=c("red", "#E69F00", "#56B4E9", "gray")) +
scale_fill_grey(start = 0, end = 1)
v1 = gbasic +
geom_bar(mapping =  aes(y = mean), stat = "identity", color = "black") +
labs(fill = "method", title = substitute(paste("Bias of ", psi, ', ', psi, ' = ', var), list(var = round(psi0, 1))), x = NULL, y = NULL)
v2 = gbasic +
geom_bar(mapping = aes(y = rmse), stat = "identity", color = "black") +
labs(fill = "method", title = expression(paste("RMSE of ", psi)), x = NULL, y = NULL)
v3 = gbasic +
geom_bar(mapping =  aes(y = coverage), stat = "identity", color = "black") +
labs(fill = "method", title = "1 - coverage", x = NULL, y = NULL)
#pdf(paste("C:/Users/manja/Dropbox/capture_recapture/codes/images/crc_simulated_barplots/barplottheta_K2_l1_psi0", round(10*psi0), "0_alpha_sigma12_bias_rmse_cvrg.pdf", sep = ''), width = 1100/100 + length(alpha_vec - 3)*0.75, height = 400/100, onefile = FALSE) #height = 375 and 415
ggarrange(v1, v2, v3, ncol = 3, common.legend = TRUE, legend = "bottom")
datorg = numeric(0)
varorg = datorg
norg = datorg
varnorg = datorg
twolist = FALSE
psi0 =  dat_p(n0, l)$psi0
set.seed(1)
for(alp in 1:length(alpha_vec)) {
alpha = alpha_vec[alp]
for(sig in 1:length(sigma_vec)){print(c(n0, alp, sig))
sigma = sigma_vec[sig]
K = 2;l = 1
for (s in 1:simuldraw){print(s)
datap = dat_p(n0, l)
List_matrix = datap$List_matrix
N = sum(pmax(List_matrix[,1], List_matrix[,2]))
est_val = psinhat_simul(List_matrix, n = n0, K = 2, sigma = sigma, alpha = alpha, twolist = twolist, eps = 0.005, nfolds = 2)
datorg = rbind(datorg, cbind(est_val$psi, alpha, sigma, n0))
varorg = rbind(varorg, cbind(est_val$sigma2/N, alpha, sigma, n0))
norg = rbind(norg, cbind(est_val$n, alpha, sigma, n0))
varnorg = rbind(varnorg, cbind(est_val$varn, alpha, sigma, n0))
}
beep(sound = 10)
}
}
datorg = data.frame(datorg)
datorg = melt(datorg, id.vars = c("alpha", "sigma", "n0"), value.name = "psi", variable.name = "model")
varorg = data.frame(varorg)
varorg = melt(varorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varpsi", variable.name = "model")
norg = data.frame(norg)
norg = melt(norg, id.vars = c("alpha", "sigma", "n0"), value.name = "n", variable.name = "model")
varnorg = data.frame(varnorg)
varnorg = melt(varnorg, id.vars = c("alpha", "sigma", "n0"), value.name = "varn", variable.name = "model")
psidata = merge(datorg, varorg, by = c("model", 'alpha', 'sigma', "n0"))
psidata$alpha = as.numeric(as.character(psidata$alpha))
psidata$sigma = as.numeric(as.character(psidata$sigma))
psidata$psi0 = psi0
ndata = merge(norg, varnorg, by = c('model', 'alpha', 'sigma', "n0"))
ndata$alpha = as.numeric(as.character(ndata$alpha))
ndata$sigma = as.numeric(as.character(ndata$sigma))
################### Plots for psi as capture probability
dat_pibctr_summary = ddply(psidata, c("alpha", "sigma", "n0", "model"), summarise,
mean = mean(abs(psi - psi0)),
rmse = sqrt(mean((psi - psi0)^2)),
sd = sqrt(var(psi))
)
dat_pibctr_summary$coverage = NA
############## manually calculating coverage due to error on line 211-212
for(alpha in alpha_vec){
for(sigma in sigma_vec){
for(model in unique(dat_pibctr_summary$model)){
subdat = ndata[ndata$n0 == n0 & ndata$alpha == alpha & ndata$sigma == sigma & ndata$model == model,]
dat_pibctr_summary[dat_pibctr_summary$n0 == n0 & dat_pibctr_summary$alpha == alpha &
dat_pibctr_summary$sigma == sigma & dat_pibctr_summary$model == model,
]$coverage = mean(abs(subdat$n0 - subdat$n) <= sqrt(subdat$varn)*1.95, na.rm = TRUE)
}
}
}
dat_pibctr_summary$coverage = 1 - dat_pibctr_summary$coverage
tsize = 16
gbasic = ggplot(data = dat_pibctr_summary, aes(x = factor(model), fill = factor(model))) +
theme_bw() +
theme(text = element_text(size = tsize), axis.text.x = element_blank(), axis.ticks.x=element_blank(), axis.title.x=element_blank(), legend.position = "bottom") +
facet_grid(sigma ~ alpha, labeller = label_both, scales = "free_y") +
#scale_fill_manual("Estimation method", values=c("red", "#E69F00", "#56B4E9", "gray")) +
scale_fill_grey(start = 0, end = 1)
v1 = gbasic +
geom_bar(mapping =  aes(y = mean), stat = "identity", color = "black") +
labs(fill = "method", title = substitute(paste("Bias of ", psi, ', ', psi, ' = ', var), list(var = round(psi0, 1))), x = NULL, y = NULL)
v2 = gbasic +
geom_bar(mapping = aes(y = rmse), stat = "identity", color = "black") +
labs(fill = "method", title = expression(paste("RMSE of ", psi)), x = NULL, y = NULL)
v3 = gbasic +
geom_bar(mapping =  aes(y = coverage), stat = "identity", color = "black") +
labs(fill = "method", title = "1 - coverage", x = NULL, y = NULL)
#pdf(paste("C:/Users/manja/Dropbox/capture_recapture/codes/images/crc_simulated_barplots/barplottheta_K2_l1_psi0", round(10*psi0), "0_alpha_sigma12_bias_rmse_cvrg.pdf", sep = ''), width = 1100/100 + length(alpha_vec - 3)*0.75, height = 400/100, onefile = FALSE) #height = 375 and 415
ggarrange(v1, v2, v3, ncol = 3, common.legend = TRUE, legend = "bottom")
devtools::document()
#---------------------------------------------------------------------------
#    Kill estimate by different departamentos
#---------------------------------------------------------------------------
devtools::install("C:/Users/manja/Onedrive/Documents/crctmle")
library(crctmle)
source("C:/Users/manja/Dropbox/capture_recapture/codes/indep_cov_Tilling_simulation.R")
source("C:/Users/manja/Dropbox/capture_recapture/codes/indep_cov_bias_sqmse_functions.R")
source("C:/Users/manja/Dropbox/capture_recapture/codes/superlearner_function.R")
source("C:/Users/manja/Dropbox/capture_recapture/codes/psi_indep_tmle_crossfitting_corrected.R")
source("C:/Users/manja/Dropbox/capture_recapture/codes/peru_codes/peru_1.R")
K = 2
eps = 0.005
provyes = FALSE
list2 = pmax(x[,16], x[,17])
misage = rep(1, length(age))
misage[is.na(age)] = 0
age_nona = age
age_nona[is.na(age_nona)] = 0
iddpto = round(ui/10000)
idprov = round(ui/100)
datap0 = cbind(x[,c(10)], list2, age_nona, perpe1, misage, x[,c(2, 6)], ui, iddpto, idprov, strata)
datap0 = merge(datap0, depcoord, by.x = "iddpto", by.y = "IDDPTO", all.x = TRUE)
datap0 = merge(datap0, cordarea, by.x = "strata", by.y = "strata", all.x = TRUE)
datap0 = merge(datap0, provcoord, by.x = "idprov", by.y = "IDPROV", all.x = TRUE)
if(provyes == FALSE){
datap0 = datap0[,-grep("_p", names(datap0))]
}
datap0 = datap0[,-which(names(datap0) %in% c("ui", "idprov", "strata"))]
datap0$Sexo[which(is.na(datap0$Sexo))] = 'N'
datap0$misage = factor(datap0$misage)
datap0$Sexo = factor(datap0$Sexo)
datap0$perpe1 = factor(datap0$perpe1)
datap0$Situacion = factor(datap0$Situacion)
datap0 = data.frame(datap0)
delcol = which(names(datap0) %in% c("misage", "Sexo", "Situacion", "ubina", "depna", "provna"))
datap_modelmatrix = cbind(datap0[,-delcol], model.matrix(~misage + Sexo + Situacion, datap0))
funcname = c("logit"
#"Mlogit",
#"NP",
# "Gam"
,"sl"
)
nmat = matrix(NA, nrow = 25, ncol = 6*length(funcname))
varnmat = nmat
psimat = nmat
varpsimat = nmat
set.seed(123)
for (departmentos in 1:25){#c(5,9,10,12)){
nvec = numeric(0)
varnvec = nvec
psivec = numeric(0)
varpsivec = nvec
for (agent in 1:2){
print(c("d a", departmentos, agent))
K = 2
datapset = datap_modelmatrix[
datap_modelmatrix$iddpto %in% c(departmentos) & datap_modelmatrix$perpe1 %in% c(agent),
-which(names(datap_modelmatrix) %in% c("iddpto", "perpe1"))]
if(sum(is.na(datapset$x_p))/nrow(datap_modelmatrix) > 0.3) {
datapset = datapset[,-grep("_p", names(datapset))]
}
datapset = datapset[,-which(apply(datapset[,!(names(datapset) %in% c("(Intercept)"))], 2, function(col){length(unique(col)) <= 1}))[-1]]
#datapset = datapset[,-which(sapply(colnames(datapset), function(col){
#  (!(col %in% c("x...c.10..", "list2", "(Intercept)")))&(length(unique(datapset[,col])) <= 1)}))]
n = length(intersect(which(idepa == departmentos), which(perpe == agent)))
l = ncol(datapset) - K
if(length(datapset) < 3){
print("no")
nvec = cbind(nvec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
varnvec = cbind(varnvec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
psivec = cbind(psivec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
varpsivec = cbind(varpsivec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
}else if((min(c("x...c.10..", "list2")%in% names(datapset)) == 0) | nrow(datapset) <= 10 | sum(datapset[,1]*datapset[,2]) <= 5) {
print("no")
nvec = cbind(nvec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
varnvec = cbind(varnvec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
psivec = cbind(psivec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
varpsivec = cbind(varpsivec, matrix(n, ncol = 3*length(funcname), nrow = K*(K - 1)/2))
}else{
print("yes")
List_matrix = na.omit(datapset)
N = nrow(List_matrix)
est_val = psinhat(List_matrix, K = K, funcname = funcname, nfolds = 2, eps = eps)
nvec = cbind(nvec, (est_val$n))
varnvec = cbind(varnvec, (est_val$varn))
psivec = cbind(psivec, (est_val$psi))
varpsivec = cbind(varpsivec, (est_val$sigma2))
if (sum(est_val$n_summary == "NaN") > 1){
nvec[nvec == "NaN"] = n
varnvec[varnvec == "NaN"] = 0
psivec[psivec == "NaN"] = n
varpsivec[varpsivec == "NaN"] = 0
}
}
}
nmat[departmentos,] = nvec
varnmat[departmentos,] = varnvec
psimat[departmentos,] = psivec
varpsimat[departmentos,] = varpsivec
}
output_n = nmat
colnames(output_n) = paste(rep(c("EST", "SLU"), each = 3*length(funcname)), rep(paste(rep(c('P', 'SL'), each = 3), c('_PI', "_BC", "_TMLE"), sep = ''), 2), sep = '_')
colnames(nmat) = colnames(output_n)
colnames(psimat) = colnames(output_n)
colnames(varpsimat) = colnames(output_n)
colnames(varnmat) = colnames(output_n)
save(nmat, varnmat, psimat, varpsimat, orgsize, output_n, file = "C:/Users/manja/Dropbox/capture_recapture/codes/Peru_codes/department_kills_for_map_eps0005.Rdata")
orgsize = matrix(NA, ncol = 6, nrow = 25)
for (departmentos in 1:25){
for (agent in 1:2){
print(c("d a", departmentos, agent))
K = 2
datapset = datap_modelmatrix[
datap_modelmatrix$iddpto %in% c(departmentos) & datap_modelmatrix$perpe1 %in% c(agent),
-which(names(datap_modelmatrix) %in% c("iddpto", "perpe1"))]
n = length(intersect(which(idepa == departmentos), which(perpe == agent)))
N = nrow(na.omit(datapset))
orgsize[departmentos, (agent*2 - 1):(agent*2)] = c(n, N)
}
}
colnames(orgsize) = c("EST_n", "EST_N", "SLU_n", "SLU_N", "OTR_n", "OTR_N")
save(nmat, varnmat, psimat, varpsimat, orgsize, output_n, file = "C:/Users/manja/Dropbox/capture_recapture/codes/Peru_codes/department_kills_for_map_eps0005.Rdata")
library(ggmap)
library(ggplot2)
library(raster)
library(maptools)
library(maps)
library(viridis)
library(reshape2)
#remotes::install_github("tylermorganwall/rayshader")
library(rayshader)
library(tidyverse)
library(sf)
peru = st_read("C:/Users/manja/Dropbox/capture_recapture/data/Peru_killings/shape_files/DEPARTAMENTOS.shp", quiet = TRUE)
k = 1
#load("C:/Users/manja/Dropbox/capture_recapture/codes/Peru_codes/department_kills_for_map_eps0005.Rdata")
slu_est_diff = output_n[,str_subset(colnames(output_n),"SLU_SL")] -
output_n[,str_subset(colnames(output_n),"EST_SL")]
colnames(slu_est_diff) = gsub("SLU_", "", str_subset(colnames(output_n),"SLU_SL"))
library(scales) #for trans_new
modulus_trans <- function(lambda){
trans_new("modulus",
transform = function(y){
if(lambda != 0){
yt <- sign(y) * (((abs(y) + 1) ^ lambda - 1) / lambda)
} else {
yt = sign(y) * (log(abs(y) + 1))
}
return(yt)
},
inverse = function(yt){
if(lambda != 0){
y <- ((abs(yt) * lambda + 1)  ^ (1 / lambda) - 1) * sign(yt)
} else {
y <- (exp(abs(yt)) - 1) * sign(yt)
}
return(y)
}
)
}
charcols = function(charvec, nrow){
return(matrix(rep(unlist(charvec), nrow), nrow = nrow, byrow = TRUE))
}
colvecvalue = cbind(slu_est_diff[,1], charcols(strsplit(colnames(slu_est_diff)[1], '_'), 25))
peru_dep = cbind(peru, colvecvalue)
colvecvalue = cbind(slu_est_diff[,2], charcols(strsplit(colnames(slu_est_diff)[2], '_'), 25))
peru_dep = rbind(peru_dep, cbind(peru, colvecvalue))
colvecvalue = cbind(slu_est_diff[,3], charcols(strsplit(colnames(slu_est_diff)[3], '_'), 25))
peru_dep = rbind(peru_dep, cbind(peru, colvecvalue))
colnames(peru_dep)[5:7] = c("difference", "model", "method")
peru_dep$difference = as.numeric(as.character(peru_dep$difference))
peru_dep$model = factor(peru_dep$model, levels = c('P', 'SL'))
peru_dep$method = factor(peru_dep$method, levels = c("PI", "BC", "TMLE"))
label_vec = c(round(min(slu_est_diff)), -1500, -1000, -500, -100, 0, 100,  500, 1000, 1500, round(max(slu_est_diff)))
gmodulus = ggplot(peru_dep[peru_dep$model != "SjL",]) +
geom_sf(aes(fill = difference)) +
scale_fill_gradient2(trans = #"identity",
modulus_trans(0.5),
# midpoint = 0,#zero,
low = "dodgerblue1",#"#56B4E9", ,
mid = "white",
high = "yellow2",#"#E69F00",# "#FFD700",#,#"goldenrod3"
space = "Lab",
limits = c(min(peru_dep$difference)-1, max(peru_dep$difference)+1)
, breaks = label_vec, labels = label_vec
) +
#facet_grid(model~method) +
facet_wrap(~method) +
ggtitle("Difference in the estimated number of killings between the\nPCP-Shining Path and the State") +
theme_bw() +
theme(text = element_text(size=12), axis.text.x = element_text(angle = 90), legend.position = "bottom", legend.key.width = unit(2.5, "cm"))
gmodulus
psinhat
pdf("C:/Users/manja/Dropbox/capture_recapture/codes/images/peru_kill_map/kill_slu_est_diff_P_SL_1_23_eps0005.pdf")
gmodulus
dev.off()
output_n[c(3,9),]
output_n[c(3,9),]
install_github("mqnjqrid/crctmle")
devtools::install_github("mqnjqrid/crctmle")
devtools::document()
source('~/crctmle/R/estimate_psi_n_controlled_errors.R')
devtools::document()

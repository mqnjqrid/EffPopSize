hist(estim[,"logit PI"])
abline(v = 2000)
hist(estim[,"logit PI"])
abline(v = 2000)
abline(v = 2000)
abline(v = 1000)
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
vline(v = 1000)
hist(estim[,"logit BC"])
vline(v = 1000)
hist(estim[,"logit TMLE"])
vline(v = 1000)
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abine(v = 1000)
hist(estim[,"logit BC"])
abine(v = 1000)
hist(estim[,"logit TMLE"])
abine(v = 1000)
abine(h = 1000)
abline(h = 1000)
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = 1000)
hist(estim[,"logit BC"])
abline(v = 1000)
hist(estim[,"logit TMLE"])
abline(v = 1000)
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(xi)), expit(sum(xi))))}))
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(xi)), expit(sum(xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(2*xi), expit(2*x)))}))
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(xi)), expit(sum(xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(2*xi), expit(2*xi)))}))
datacrc = cbind(y1, y2, x)
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
summary(y1)
summary(y2)
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(-xi)), expit(sum(-xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(xi/2), expit(xi/2)))}))
datacrc = cbind(y1, y2, x)
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abine(v = n)
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(-xi)), expit(sum(-xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(xi/2), expit(xi/2)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0.5), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
tmle = function(datmat, iter = 100, eps = 0.005, eps_stop = 0.00001, twolist = FALSE, K = 2){
if(!prod(c("yi", "yj", "yij", "q10", "q02", "q12") %in% colnames(datmat))){
stop("datmat misses one or more of the following columns: \t (yi, yj, yij, q10, q02, q12).")
return(list(error = TRUE))
}
expit = function(x) {
exp(x)/(1 + exp(x))
}
logit = function(x) {
log(x/(1 - x))
}
epsilon_error = 1
cnt = 0
while (abs(epsilon_error) > eps_stop){
cnt = cnt + 1
if (cnt > iter){break}
########################### model 1 for q12
dat1 = cbind(datmat$yij, logit(datmat$q12), (datmat$q10 + datmat$q12)/datmat$q12
+ (datmat$q02 + datmat$q12)/datmat$q12
- (datmat$q10 + datmat$q12)*(datmat$q02 + datmat$q12)/datmat$q12^2 )
colnames(dat1) = c("yij", "logitq12", "ratio")
dat1 = as.data.frame(dat1)
mod1 = try(glm(yij ~ -1 + offset(logitq12) + ratio
, family = binomial(link = logit), data = dat1, na.action = na.omit))
if (!("try-error" %in% class(mod1))){
datmat[,"q12"] = predict(mod1, newdata = dat1, type = "response")
}
datmat$q12 = pmax(pmin(datmat$q12, 1), eps)
########################### model 2 for q1
dat2 = cbind(datmat$yi*(1 - datmat$yj), logit(datmat$q10), (datmat$q02 + datmat$q12)/datmat$q12)
colnames(dat2) = c("yi0", "logitq10", "ratio")
dat2 = as.data.frame(dat2)
mod2 = try(glm(yi0 ~ -1 + offset(logitq10) + ratio, family = binomial(link = logit), data = dat2, na.action = na.omit))
if (!("try-error" %in% class(mod2))){
datmat$q10 = predict(mod2, newdata = dat2, type = "response")
datmat[,"q10"] = pmin(datmat[,"q10"], 1 - datmat$q12)
}
datmat$q10 = pmax(pmin(datmat$q10, 1), eps)
########################### model 3 for q2
if (K > 2 | twolist == FALSE){
dat3 = cbind(datmat$yj*(1 - datmat$yi), logit(datmat$q02), (datmat$q10 + datmat$q12)/datmat$q12)
colnames(dat3) = c("y0j", "logitq02", "ratio")
dat3 = as.data.frame(dat3)
mod3 = try(glm(y0j ~ -1 + offset(logitq02) + ratio, family = binomial(link = logit), data = dat3, na.action = na.omit))
if (!("try-error" %in% class(mod3))){
datmat$q02 = predict(mod3, newdata = dat3, type = "response")
datmat[,"q02"] = pmin(datmat[,"q02"], 1 - datmat$q10 - datmat$q12)
}
}else{
mod3 = mod2
datmat[,"q02"] = pmax(0, 1 - datmat$q10 - datmat$q12)
}
datmat$q02 = pmax(pmin(datmat$q02, 1), eps)
epsilon_error = max(abs(c(mod2$coefficients, mod3$coefficients, mod1$coefficients)))
}
return(list(error = epsilon_error > 1, datmat = datmat))
}
#' data = matrix(sample(c(0,1), 2000, replace = TRUE), ncol = 2)
#' x = matrix(rnorm(nrow(data)*3, 2,1), nrow = nrow(data))
#'
#' psin_estimate = psinhat(List_matrix = data)
#' #this returns the basic plug-in estimate since covariates are absent.
#'
#' data = cbind(data, x)
#' psin_estimate = psinhat(List_matrix = data, funcname = c("logit", "sl"), nfolds = 2, twolist = FALSE, eps = 0.005)
#' #this returns the plug-in, the bias-corrected and the tmle estimate for the two models
#' @export
psinhat = function(List_matrix, K = 2, funcname = c("logit"), nfolds = 5, twolist = FALSE, eps = 0.005, iter = 50){
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
stopifnot(K >= 2)
stopifnot(nrow(List_matrix)>1)
stopifnot(ncol(List_matrix) >= 2)
stopifnot(((ncol(List_matrix) == K)&(nrow(List_matrix)>50)) | (nrow(List_matrix) > 0))
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
stop("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
Message(cat("Lists ", which(conforminglists == FALSE), " are not in the required format."))
}
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 1)
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ", ", s, sep = ''))
})}))
colnames(psiinv_summary) =  c("PI")
var_summary = psiinv_summary
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
next
}
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
psiinv_summary[paste(i, ", ", j, sep = ''),] = q1*q2/q12
var_summary[paste(i, ", ", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
}
}
}else{
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ", ", s, sep = ''))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
var_summary = psiinv_summary
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(NA, nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c(" PI", " BC", " TMLE"), sep = '')
varmat = psiinvmat
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
for (func in funcname){
colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, colsubset][1:2] = c(psiinvhat, psiinvhatq)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, colsubset][1:2] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
tmle = tmle(datmat = datmat, iter = iter, eps = eps, eps_stop = 0.00001, twolist = twolist, K = K)
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds,colsubset][3] = psiinvhat
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds,colsubset][3] = sigmasq/N
}
}
}else{
message(cat("Overlap between the lists", i, "and", j, "is less than", eps))
psiinvmat[folds,] = NA
varmat[folds,] = NA
}
}
psiinv_summary[paste(i, ", ", j, sep = ''),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste(i, ", ", j, sep = ''),] = colMeans(varmat, na.rm = TRUE)
}
}
}
return(list(psi = 1/psiinv_summary, sigma2 = N*var_summary,
n = N*psiinv_summary,
varn = N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1),
N = N
))
}
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(-xi)), expit(sum(-xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(xi/2), expit(xi/2)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0.5), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(sum(-xi)), expit(sum(-xi))))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-xi/2), expit(-xi/2)))}))
summary(y1)
summary(y2)
summary(y1*y2)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0.5), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
n = 5000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0.5), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:500, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
abline(v = n)
n = 1000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0), nrow = n))
mean((1-y1)*(1-y2))
1 - mean((1-y1)*(1-y2))
library(crctmle)
n = 10000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, x + matrix(rnorm(n*3, 0, 0.5), nrow = n))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n)
hist(estim[,"logit BC"])
abline(v = n)
hist(estim[,"logit TMLE"])
abline(v = n)
library(crctmle)
n = 10000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2), nrow = n))
devtools::document()
library(crctmle)
n = 10000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, eps = 0.01)$n)
}))
library(crctmle)
n = 10000
x = matrix(rnorm(n*3, 2,1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
options(warn = -1)
estim <- do.call("rbind", lapply(1:50, function(iter){
return(psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, eps = 0.01)$n)
}))
par(mfrow = c(1,3))
hist(estim[,"logit PI"])
abline(v = n, col = "red")
hist(estim[,"logit BC"])
abline(v = n, col = "red")
hist(estim[,"logit TMLE"])
abline(v = n, col = "red")
lirary(reshape2);result = melt(estim, variable.name = "Estimator", value.name = "population size")
library(reshape2);result = melt(estim, variable.name = "Estimator", value.name = "population size")
library(ggplot2)
library(reshape2);result = melt(estim, variable.name = "Estimator", value.name = "population_size")
library(ggplot2)
ggplot(result, aes(x = population_size, fill = estimator))+geom_histogram() + geom_line(x_intercept = n)
head(result)
library(reshape2);result = melt(as.data.frame(estim), variable.name = "Estimator", value.name = "population_size")
head(result)
library(ggplot2)
ggplot(result, aes(x = population_size, fill = estimator))+geom_histogram() + geom_line(x_intercept = n)
ggplot(result, aes(x = population_size, fill = Estimator))+geom_histogram() + geom_line(x_intercept = n)
ggplot(result, aes(x = population_size, fill = Estimator))+geom_histogram()
ggplot(result, aes(x = population_size, fill = Estimator))+geom_histogram(bins = 10)
ggplot(result, aes(x = population_size, fill = Estimator))+geom_histogram(bins = 20)
ggplot(result, aes(x = population_size - n, fill = Estimator))+geom_histogram()
ggplot(result, aes(x = population_size - n, fill = Estimator))+geom_density()
ggplot(result, aes(x = population_size - n, color = Estimator))+geom_density()
ggplot(result, aes(x = population_size - n, color = Estimator))+geom_density()
ggplot(result, aes(x = population_size - n, fill = Estimator))+geom_density(alpha = 0.4)
ggplot(result, aes(x = population_size - n, fill = Estimator, color = Estimator))+geom_density(alpha = 0.4)
ggplot(result, aes(x = population_size - n, fill = Estimator, color = Estimator))+geom_density(alpha = 0.4) + xlab("Bias of n")
library(crctmle)
n = 1000
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
options(warn = -1)
estim <- psinhat(List_matrix = datacrc, func = c("logit"), nfolds = 2, K = 2)
# The population size estimates are obtained by
estim$n
# The corresponding variances are
estim$varn
## basic example code
devtools::document()

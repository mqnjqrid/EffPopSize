}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(numeric(0), nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
varmat = psiinvmat
ifvalsfold = matrix(numeric(0), nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(numeric(0), nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
overlapij = mean(List1[,i]*List1[,j])
if(overlapij < eps) {
warning(cat("Overlap between the lists ", i, " and ", j, " is less than ", eps, '.\n', sep = ''))
}
for (func in funcname){
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List.train = List1, List.test = List2, K, i, j, eps = eps,...), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhat.dr = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, paste(func, c("PI", "DR"), sep = '.')] = c(psiinvhat, psiinvhat.dr)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, c("PI", "DR"), sep = '.')] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
if(TMLE) {
tmle = tmle(datmat = datmat, eps = eps, K = K, ...)
}else{
tmle = list(error = TRUE)
}
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = NA
varmat[folds, paste(func, "TMLE", sep = '.')] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat.tmle = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat.tmle
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = psiinvhat.tmle
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, "TMLE", sep = '.')] = sigmasq/N
}
}
}
psiinv_summary[paste0(i, ",", j),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste0(i, ",", j),] = colMeans(varmat, na.rm = TRUE)
ifvals[ifvals[,"listpair"] == paste0(i, ",", j), colnames(ifvals) != "listpair"] = ifvalsfold
nuis[nuis[, "listpair"] == paste0(i, ",", j), colnames(nuis) != "listpair"] = nuisfold
nuistmle[nuistmle[, "listpair"] == paste0(i, ",", j), colnames(nuistmle) != "listpair"] = nuistmlefold
}
}
result <- list(psi = 1/psiinv_summary, sigma = sqrt(N*var_summary), n = round(N*psiinv_summary),
sigman = sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)),
cin.l = round(pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N)),
cin.u = round(N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))))
result <- Reduce(function(...) merge(..., by = c("listpair", "Var2")),
lapply(1:length(result), function(i)
reshape2::melt(result[[i]], value.name = names(result)[i], varnames = c("listpair", "Var2"))))
result <- separate(data = result, col = "Var2", into = c("model", "method"), sep = '\\.')
result
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(numeric(0), nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
varmat = psiinvmat
ifvalsfold = matrix(numeric(0), nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(numeric(0), nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
overlapij = mean(List1[,i]*List1[,j])
if(overlapij < eps) {
warning(cat("Overlap between the lists ", i, " and ", j, " is less than ", eps, '.\n', sep = ''))
}
for (func in funcname){
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List.train = List1, List.test = List2, K, i, j, eps = eps), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhat.dr = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, paste(func, c("PI", "DR"), sep = '.')] = c(psiinvhat, psiinvhat.dr)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, c("PI", "DR"), sep = '.')] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
if(TMLE) {
tmle = tmle(datmat = datmat, eps = eps, K = K)
}else{
tmle = list(error = TRUE)
}
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = NA
varmat[folds, paste(func, "TMLE", sep = '.')] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat.tmle = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat.tmle
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = psiinvhat.tmle
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, "TMLE", sep = '.')] = sigmasq/N
}
}
}
psiinv_summary[paste0(i, ",", j),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste0(i, ",", j),] = colMeans(varmat, na.rm = TRUE)
ifvals[ifvals[,"listpair"] == paste0(i, ",", j), colnames(ifvals) != "listpair"] = ifvalsfold
nuis[nuis[, "listpair"] == paste0(i, ",", j), colnames(nuis) != "listpair"] = nuisfold
nuistmle[nuistmle[, "listpair"] == paste0(i, ",", j), colnames(nuistmle) != "listpair"] = nuistmlefold
}
}
result <- list(psi = 1/psiinv_summary, sigma = sqrt(N*var_summary), n = round(N*psiinv_summary),
sigman = sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)),
cin.l = round(pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N)),
cin.u = round(N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))))
result <- Reduce(function(...) merge(..., by = c("listpair", "Var2")),
lapply(1:length(result), function(i)
reshape2::melt(result[[i]], value.name = names(result)[i], varnames = c("listpair", "Var2"))))
result <- separate(data = result, col = "Var2", into = c("model", "method"), sep = '\\.')
result
#' psin_estimate = psinhat(List_matrix = data)
#' #this returns the basic plug-in estimate since covariates are absent.
#'
#' data = cbind(data, x)
#' psin_estimate = psinhat(List_matrix = data, funcname = c("logit", "sl"), nfolds = 2, twolist = FALSE, eps = 0.005)
#' #this returns the plug-in, the bias-corrected and the tmle estimate for the two models
#setClass("psinhat", contains = "list")
# @exportClass psinhat
#setMethod("print", "psinhat", print.psinhat)
#' @export
psinhat <- function(List_matrix, K = 2, filterrows = FALSE, funcname = c("rangerlogit"), nfolds = 5, eps = 0.005,
sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), Nmin = 500, TMLE = TRUE, ...){
require("tidyverse", quietly = TRUE, warn.conflicts = FALSE)
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
if(!informat(List_matrix = List_matrix, K = K)){
List_matrix <- reformat(List_matrix = List_matrix, capturelists = 1:K)
}
List_matrix = na.omit(List_matrix)
if(filterrows){
#removing all rows with only 0's
List_matrix = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
}
List_matrix = as.data.frame(List_matrix)
#N = number of observed or captured units
N = nrow(List_matrix)
stopifnot(N > 1)
if (l >= 0 & N < Nmin){
l = 0
warning(cat("Insufficient number of observations for doubly-robust estimation."))
}
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
stop("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
Message(cat("Lists ", which(conforminglists == FALSE), " are not in the required format."))
}
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''))
listpair = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste(k, ",", s, sep = ''))
})}))
psiinv = data.frame(listpair = listpair)
psiinv$psiin = NA
psiinv$sigma = NA
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
next
}
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
psiinv[psiinv$listpair == paste0(i, ",", j),]$psiin = q1*q2/q12
psiinv[psiinv$listpair == paste0(i, ",", j),]$sigma = sqrt(q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N)
}
}
result <- psiinv %>% mutate(psi = 1/psiin, sigma = sqrt(N)*sigma, n = round(N*psiin),
sigman = sqrt(N^2*sigma^2 + N*psiin*(psiin - 1)),
cin.l = round(pmax(N*psiin - 1.96*sqrt(N^2*sigma^2 + N*psiin*(psiin - 1)), N)),
cin.u = round(N*psiin + 1.96 *sqrt(N^2*sigma^2 + N*psiin*(psiin - 1)))) %>% as.data.frame()
result = subset(result, select = -c("psiin"))
object = list(result = result, N = N)
class(object) = "psinhat"
return(object)
}else{
#renaming the columns of List_matrix for ease of use
colnames(List_matrix) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
if(nfolds > 1 & nfolds > N/50) {
nfolds = pmax(floor(N/50), 1)
cat("nfolds is reduced to ", nfolds, " to have sufficient test data.\n")
}
psiinv_summary = matrix(0, nrow = K*(K - 1)/2, ncol = 3*length(funcname))
rownames(psiinv_summary) = unlist(sapply(1:(K - 1), function(k) {
sapply((k + 1):K, function(s) {
return(paste0(k, ",", s))
})}))
colnames(psiinv_summary) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
var_summary = psiinv_summary
ifvals = matrix(NA, nrow = N*K*(K-1)/2, ncol = length(funcname) + 1)
colnames(ifvals) = c("listpair", funcname)
ifvals[,"listpair"] = rep(rownames(psiinv_summary), each = N)
nuis = matrix(NA, nrow = N*K*(K-1)/2, ncol = 3*length(funcname) + 1)
colnames(nuis) = c("listpair", paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.'))
nuis[,"listpair"] = ifvals[,"listpair"]
nuistmle = nuis
permutset = sample(1:N, N, replace = FALSE)
for(i in 1:(K - 1)){
if(!setequal(List_matrix[,i], c(0,1))){
#     cat("List ", i, " is not in the required format or is degenerate.\n")
next
}
for(j in (i + 1):K){
if(!setequal(List_matrix[,j], c(0,1))){
#       cat("List ", j, " is not in the required format or is degenerate.\n")
next
}
psiinvmat = matrix(numeric(0), nrow = nfolds, ncol = 3*length(funcname))
colnames(psiinvmat) = paste(rep(funcname, each = 3), c("PI", "DR", "TMLE"), sep = '.')
varmat = psiinvmat
ifvalsfold = matrix(numeric(0), nrow = N, ncol = length(funcname))
colnames(ifvalsfold) = funcname
nuisfold = matrix(numeric(0), nrow = N, ncol = 3*length(funcname))
colnames(nuisfold) = paste(rep(funcname, each = 3), c("q12", "q1", "q2"), sep = '.')
nuistmlefold = nuisfold
for(folds in 1:nfolds){#print(folds)
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
}
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
overlapij = mean(List1[,i]*List1[,j])
if(overlapij < eps) {
warning(cat("Overlap between the lists ", i, " and ", j, " is less than ", eps, '.\n', sep = ''))
}
for (func in funcname){
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List.train = List1, List.test = List2, K, i, j, eps = eps, ...), silent = TRUE)
if ("try-error" %in% class(qhat)) {
next
}
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
nuisfold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yj/q2 + yi/q1 - yi*yj/q12) - psiinvhat
ifvalsfold[sbset, func] = phihat
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhat.dr = max(psiinvhat + Qnphihat, 1)
psiinvmat[folds, paste(func, c("PI", "DR"), sep = '.')] = c(psiinvhat, psiinvhat.dr)
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, c("PI", "DR"), sep = '.')] = sigmasq/N
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12")
if(TMLE) {
tmle = tmle(datmat = datmat, eps = eps, K = K, ...)
}else{
tmle = list(error = TRUE)
}
if(tmle$error){
warning("TMLE did not run or converge.")
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = NA
varmat[folds, paste(func, "TMLE", sep = '.')] = NA
}else{
datmat = tmle$datmat
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
nuistmlefold[sbset, paste(func, c("q12", "q1", "q2"), sep = '.')] = cbind(q12, q1, q2)
gammainvhat = q1*q2/q12
psiinvhat.tmle = mean(gammainvhat, na.rm = TRUE)
phihat = gammainvhat*(yi/q1 + yj/q2 - yi*yj/q12) - psiinvhat.tmle
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvmat[folds, paste(func, "TMLE", sep = '.')] = psiinvhat.tmle
sigmasq = var(phihat, na.rm = TRUE)
varmat[folds, paste(func, "TMLE", sep = '.')] = sigmasq/N
}
}
}
psiinv_summary[paste0(i, ",", j),] = colMeans(psiinvmat, na.rm = TRUE)
var_summary[paste0(i, ",", j),] = colMeans(varmat, na.rm = TRUE)
ifvals[ifvals[,"listpair"] == paste0(i, ",", j), colnames(ifvals) != "listpair"] = ifvalsfold
nuis[nuis[, "listpair"] == paste0(i, ",", j), colnames(nuis) != "listpair"] = nuisfold
nuistmle[nuistmle[, "listpair"] == paste0(i, ",", j), colnames(nuistmle) != "listpair"] = nuistmlefold
}
}
result <- list(psi = 1/psiinv_summary, sigma = sqrt(N*var_summary), n = round(N*psiinv_summary),
sigman = sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)),
cin.l = round(pmax(N*psiinv_summary - 1.96*sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1)), N)),
cin.u = round(N*psiinv_summary + 1.96 *sqrt(N^2*var_summary + N*psiinv_summary*(psiinv_summary - 1))))
result <- Reduce(function(...) merge(..., by = c("listpair", "Var2")),
lapply(1:length(result), function(i)
reshape2::melt(result[[i]], value.name = names(result)[i], varnames = c("listpair", "Var2"))))
result <- separate(data = result, col = "Var2", into = c("model", "method"), sep = '\\.')
if(!TMLE){
result = result[result$method != "TMLE",]
}
object = list(result = result, N = N, ifvals = as.data.frame(ifvals), nuis = as.data.frame(nuis), nuistmle = as.data.frame(nuistmle))
class(object) = "psinhat"
#print.psinhat(result)
return(object)
}
}
object = psinhat(List_matrix, funcname)
object = psinhat(List_matrix, funcname = funcname)
result <- object$result
fig <- ggplot(result, aes(x = model, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_wrap(~listpair, labeller = label_both) +
scale_color_manual("Estimation method", values = c("PI" = "red", "DR" = "#E69F00", "TMLE" = "#56B4E9")) +
theme_bw() +
theme(legend.position = "bottom", text = element_text(size = tsize))
fig
List_matrix = simuldata(n = 6000, l = 3, categorical = TRUE, ep = -3)$List_matrix;object = psinhatcond(List_matrix, funcname = funcname, condvar = "catcov")
result <- object$result
fig <- ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_grid(listpair~model, labeller = label_both) +
scale_x_discrete(name = "conditional variable (number of observations)", breaks = c(N$condvar), labels = paste(N$condvar, " (", N$N, ')', sep = '')) +
scale_color_manual("Estimation method", values = c("PI" = "red", "DR" = "#E69F00", "TMLE" = "#56B4E9")) +
theme_bw() +
theme(legend.position = "bottom", text = element_text(size = tsize))
result
class(result)
ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35))
ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_grid(listpair~model, labeller = label_both)
ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_grid(listpair~model, labeller = label_both) +
scale_x_discrete(name = "conditional variable (number of observations)", breaks = c(N$condvar), labels = paste(N$condvar, " (", N$N, ')', sep = '')) +
scale_color_manual("Estimation method", values = c("PI" = "red", "DR" = "#E69F00", "TMLE" = "#56B4E9")) +
theme_bw()
names(object)
object$N
fig <- ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_grid(listpair~model, labeller = label_both) +
scale_x_discrete(name = "conditional variable (number of observations)", breaks = c(N$condvar), labels = paste(N$condvar, " (", N$x, ')', sep = '')) +
scale_color_manual("Estimation method", values = c("PI" = "red", "DR" = "#E69F00", "TMLE" = "#56B4E9")) +
theme_bw() +
theme(legend.position = "bottom", text = element_text(size = tsize))
N <- object$N
fig <- ggplot(result, aes(x = condvar, color = method)) +
#geom_line(aes(y = n, linetype = method)) +
geom_point(aes(y = n), position=position_dodge(0.35)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u), width=.2, position=position_dodge(0.35)) +
facet_grid(listpair~model, labeller = label_both) +
scale_x_discrete(name = "conditional variable (number of observations)", breaks = c(N$condvar), labels = paste(N$condvar, " (", N$x, ')', sep = '')) +
scale_color_manual("Estimation method", values = c("PI" = "red", "DR" = "#E69F00", "TMLE" = "#56B4E9")) +
theme_bw() +
theme(legend.position = "bottom", text = element_text(size = tsize))
fig
devtools::document()
#' @references van der Laan, M. J., Polley, E. C. and Hubbard, A. E. (2008) Super Learner, Statistical Applications of Genetics and Molecular Biology, 6, article 25.
#' @examples
#' data = matrix(sample(c(0,1), 2000, replace = TRUE), ncol = 2)
#' x = matrix(rnorm(nrow(data)*3, 2,1), nrow = nrow(data))
#' ss = sample(1:6, nrow(data), replace = TRUE)
#'
#' data = cbind(data, x, ss)
#' psin_estimate = psinhatcond(List_matrix = data, funcname = c("logit", "sl"), condvar = 'ss', nfolds = 2, twolist = FALSE, eps = 0.005)
#' #this returns the plug-in, the bias-corrected and the tmle estimate for the two models conditioned on column ss
#' @export
psinhatcond <- function(List_matrix, K = 2, filterrows = FALSE, funcname = c("rangerlogit"), condvar, nfolds = 2, eps = 0.005, TMLE = TRUE, ...){
l = ncol(List_matrix) - K
n = nrow(List_matrix)
stopifnot(!is.null(dim(List_matrix)))
stopifnot(!missing(condvar))
stopifnot(is.element(condvar, colnames(List_matrix)))
List_matrix = as.data.frame(List_matrix)
conforminglists = apply(List_matrix[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
stop("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
Message(cat("Lists ", which(conforminglists == FALSE), " are not in the required format."))
}
if(!missing(condvar)){
if(is.character(condvar)){
condvar = which(colnames(List_matrix) == condvar) - K
}
}
condvar_vec = unique(List_matrix[, condvar + K])
object = NULL
for(cvar in condvar_vec){
List_matrixsub = List_matrix[List_matrix[,K + condvar] == cvar, -c(K + condvar)]
est = try(psinhat(List_matrix = List_matrixsub, K = K, filterrows = filterrows, funcname = funcname, nfolds = nfolds, TMLE = TMLE, ...), silent = TRUE)
if("try-error" %in% class(est)){
next
}
if(!('DR' %in% est$result$method)){
next
}
if(is.null(object)){
object = lapply(est, function(x) cbind.data.frame(x, condvar = cvar))
}else{
object = Map("rbind", object, lapply(est, function(x) cbind.data.frame(x, condvar = cvar)))
}
}
if(!is.null(object)){
class(object) = "psinhatcond"
return(object)
}else{
print("Error in estimation for all subsets.")
return(0)
}
}
devtools::document()
devtools::document()

class(xtest)
head(xtrain)
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = train,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
class(fiti)
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
c(class(fiti), class(fitj), class(fitij))
is.element("try-error", c(class(fiti), class(fitj), class(fitij)))
is.element("try-error", union(class(fiti), class(fitj), class(fitij)))
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
is.element("try-error", c(class(fiti), class(fitj), class(fitij)))
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
#' @param j The second list that is conditionally independent.
#' @param eps The minimum value the estimates can attain to bound them away from zero.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#'
#' @export
qhat_sl <- function(List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
require("SuperLearner")
slib = intersect(sl.lib, c("SL.glm", "SL.gam", "SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)) ,
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)) )
xtrain = List.train[,-c(1:K)]
xtest = List.test[,-c(1:K)]
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
if(is.element("try_error", c(class(fiti), class(fitj), class(fitij)))){
Warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}else{
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
}
return(list(q1 = q1, q2 = q2, q12 = q12))
}
qhat = qhat_sl(List.train = listdata1[split,], List.test = listdata1[-split,], K = 2, i = 1, j = 2)
head(qhat)
names(qhat)
head(qhat$q1)
head(qhat$q2)
head(qhat$q12)
qhat = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
List.train = listdata
List.test = listdata
xtrain = List.train[,-c(1:K)]
xtest = List.test[,-c(1:K)]
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
is.element("try_error", c(class(fiti), class(fitj), class(fitij)))
class(fiti)
c(class(fiti), class(fitj), class(fitij))
is.element("try_error", unique(c(class(fiti), class(fitj), class(fitij))))
is.element("try_error", union(class(fiti), class(fitj), class(fitij)))
is.element("try_error", Reduce(union, list(class(fiti), class(fitj), class(fitij))))
Reduce(union, list(class(fiti), class(fitj), class(fitij)))
c(class(fiti), class(fitj), class(fitij))
"try-error" %in% c(class(fiti), class(fitj), class(fitij))
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
"try-error" %in% c(class(fiti), class(fitj), class(fitij))
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
"try_error" %in% c(class(fiti), class(fitj), class(fitij))
"try-error" %in% c(class(fiti), class(fitj), class(fitij))
#' @param j The second list that is conditionally independent.
#' @param eps The minimum value the estimates can attain to bound them away from zero.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#'
#' @export
qhat_sl <- function(List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
require("SuperLearner")
slib = intersect(sl.lib, c("SL.glm", "SL.gam", "SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)),
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)))
if(ncol(List.train) == K + 1){
xtrain = data.frame(x1 = List.train[,K+1])
xtest = data.frame(x1 = List.test[,K+1])
}else{
xtrain = List.train[,-c(1:K)]
xtest = List.test[,-c(1:K)]
}
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
if("try-error" %in% c(class(fiti), class(fitj), class(fitij))){
Warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}else{
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
}
return(list(q1 = q1, q2 = q2, q12 = q12))
}
qhat = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
# par(mfrow = c(1,3), mar = c(1,2,0,0))
plot(listdata[-split,]$x1, qhat$q1, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, listdata[-split,]$L1, cex = 0.4)
plot(listdata[-split,]$x1, qhat$q2, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, listdata[-split,]$L2, cex = 0.4)
plot(listdata[-split,]$x1, qhat$q12, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, listdata[-split,]$L1*listdata[-split,]$L2, cex = 0.4)
devtools::document()
x = rnorm(2000, 2, 1)
p1 <- sapply(x, function(xi) {exp(xi)/(1 + exp(xi))})
p2 <- sapply(x, function(xi) {exp(2*xi)/(1 + exp(2*xi))})
y1 <- sapply(p1, function(pi) {sample(c(0, 1), 1, replace = TRUE, prob = c(1 - pi, pi))})
y2 <- sapply(p2, function(pi) {sample(c(0, 1), 1, replace = TRUE, prob = c(1 - pi, pi))})
listdata = data.frame(L1 = y1, L2 = y2, x1 = x)
listdata = listdata[y1+y2>0,]
split = sample(1:nrow(listdata), nrow(listdata)/2)
qhat1 = qhat_logit(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
qhat2 = qhat_gam(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
qhat3 = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
# par(mfrow = c(1,3), mar = c(1,2,0,0))
plot(listdata[-split,]$x1, qhat1$q1, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, qhat2$q1, col = "blue", cex = 0.4)
points(listdata[-split,]$x1, qhat3$q1, col = "green",  cex = 0.4)
points(listdata[-split,]$x1, listdata[-split,]$L1, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q2, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, qhat2$q2, col = "blue", cex = 0.4)
points(listdata[-split,]$x1, qhat3$q2, col = "green",  cex = 0.4)
points(listdata[-split,]$x1, listdata[-split,]$L2, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q12, col = "red", pch = 19, cex = 0.4, ylim = c(-0.1,1.1))
points(listdata[-split,]$x1, qhat2$q12, col = "blue", cex = 0.4)
points(listdata[-split,]$x1, qhat3$q12, col = "green",  cex = 0.4)
points(listdata[-split,]$x1, listdata[-split,]$L1*listdata[-split,]$L2, cex = 0.4)
x = sort(rnorm(2000, 2, 1))
p1 <- sapply(x, function(xi) {exp(xi)/(1 + exp(xi))})
p2 <- sapply(x, function(xi) {exp(2*xi)/(1 + exp(2*xi))})
y1 <- sapply(p1, function(pi) {sample(c(0, 1), 1, replace = TRUE, prob = c(1 - pi, pi))})
y2 <- sapply(p2, function(pi) {sample(c(0, 1), 1, replace = TRUE, prob = c(1 - pi, pi))})
listdata = data.frame(L1 = y1, L2 = y2, x1 = x)
listdata = listdata[y1+y2>0,]
split = sort(sample(1:nrow(listdata), nrow(listdata)/2))
qhat1 = qhat_logit(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
qhat2 = qhat_gam(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
qhat3 = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
# par(mfrow = c(1,3), mar = c(1,2,0,0))
plot(listdata[-split,]$x1, qhat1$q1, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
line(listdata[-split,]$x1, qhat2$q1, col = "blue")
line(listdata[-split,]$x1, qhat3$q1, col = "green")
?line
# par(mfrow = c(1,3), mar = c(1,2,0,0))
plot(listdata[-split,]$x1, qhat1$q1, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q1, col = "blue")
lines(listdata[-split,]$x1, qhat3$q1, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L1, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q2, col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q2, col = "blue")
lines(listdata[-split,]$x1, qhat3$q2, col = "green")
# par(mfrow = c(1,3), mar = c(1,2,0,0))
plot(listdata[-split,]$x1, qhat1$q1, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q1, col = "blue")
lines(listdata[-split,]$x1, qhat3$q1, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L1, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q2, col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q2, col = "blue")
lines(listdata[-split,]$x1, qhat3$q2, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L2, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q12, col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q12, col = "blue")
lines(listdata[-split,]$x1, qhat3$q12, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L1*listdata[-split,]$L2, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q1, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q1, col = "blue")
lines(listdata[-split,]$x1, qhat3$q1, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L1, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q2, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q2, col = "blue")
lines(listdata[-split,]$x1, qhat3$q2, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L2, cex = 0.4)
plot(listdata[-split,]$x1, qhat1$q12, type = 'l', col = "red", pch = 19, ylim = c(-0.1,1.1))
lines(listdata[-split,]$x1, qhat2$q12, col = "blue")
lines(listdata[-split,]$x1, qhat3$q12, col = "green")
points(listdata[-split,]$x1, listdata[-split,]$L1*listdata[-split,]$L2, cex = 0.4)
qhat3 = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
#' @param j The second list that is conditionally independent.
#' @param eps The minimum value the estimates can attain to bound them away from zero.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#'
#' @export
qhat_sl <- function(List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
))
#' @param j The second list that is conditionally independent.
#' @param eps The minimum value the estimates can attain to bound them away from zero.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#'
#' @export
qhat_sl <- function(List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
require("SuperLearner")
slib = intersect(sl.lib, c("SL.glm", "SL.gam", "SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)),
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)))
if(ncol(List.train) == K + 1){
xtrain = data.frame(x1 = List.train[,K+1])
xtest = data.frame(x1 = List.test[,K+1])
}else{
xtrain = List.train[,-c(1:K)]
xtest = List.test[,-c(1:K)]
}
suppressWarnings(
fiti = try(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
)
if("try-error" %in% c(class(fiti), class(fitj), class(fitij))){
Warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}else{
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
}
return(list(q1 = q1, q2 = q2, q12 = q12))
}
qhat3 = suppressWarnings(qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2))
qhat3 = suppressMessages(qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2))
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
class(fiti)
#' @param j The second list that is conditionally independent.
#' @param eps The minimum value the estimates can attain to bound them away from zero.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#'
#' @export
qhat_sl <- function(List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005, sl.lib = c("SL.gam", "SL.glm", "SL.glm.interaction", "SL.ranger", "SL.glmnet")){
require("SuperLearner")
slib = intersect(sl.lib, c("SL.glm", "SL.gam", "SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)),
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)))
if(ncol(List.train) == K + 1){
xtrain = data.frame(x1 = List.train[,K+1])
xtest = data.frame(x1 = List.test[,K+1])
}else{
xtrain = List.train[,-c(1:K)]
xtest = List.test[,-c(1:K)]
}
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[,i], List.train[,j])),
X = xtrain,
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
if("try-error" %in% c(class(fiti), class(fitj), class(fitij))){
Warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}else{
q12 = pmax(pmin(
predict(fitij, newdata = xtest, onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = xtest, onlySL = TRUE)$pred, q12), 1)
}
return(list(q1 = q1, q2 = q2, q12 = q12))
}
qhat3 = qhat_sl(List.train = listdata[split,], List.test = listdata[-split,], K = 2, i = 1, j = 2)
devtools::document
devtools::document()
rm(list = c("qhat_sl"))
devtools::document()
n = 1000
x = matrix(rnorm(n*3, 2, 1), nrow = n)
expit = function(xi) {
exp(sum(xi))/(1 + exp(sum(xi)))
}
y1 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.4*xi), expit(-0.6 + 0.4*xi)))}))
y2 = unlist(apply(x, 1, function(xi) {sample(c(0, 1), 1, replace = TRUE, prob = c( 1 - expit(-0.6 + 0.3*xi), expit(-0.6 + 0.3*xi)))}))
datacrc = cbind(y1, y2, exp(x/2))
p = psinhat(List_matrix = datacrc[1:1000,])
ss = sample(1:6, nrow(datacrc), replace = TRUE)
datacrc1 = cbind(datacrc, ss)
p = psinhatcond(List_matrix = datacrc1[1:1000,], condvar = 'ss')
library(EffPopSize)
p = psinhatcond(List_matrix = datacrc1[1:1000,], condvar = 'ss')
p
p
psinhatcond = p
psi <- reshape2::melt(psinhatcond$psi, id.vars = c("listpair", "condvar"), value.name = "psi")
sigma2 <- reshape2::melt(psinhatcond$sigma2, id.vars = c("listpair", "condvar"), value.name = "sigma2")
n <- reshape2::melt(psinhatcond$n, id.vars = c("listpair", "condvar"), value.name = "n")
varn <- reshape2::melt(psinhatcond$varn, id.vars = c("listpair", "condvar"), value.name = "varn")
N <- psinhatcond$N
cin.l <- reshape2::melt(psinhatcond$cin.l, id.vars = c("listpair", "condvar"), value.name = "cin.l")
cin.u <- reshape2::melt(psinhatcond$cin.u, id.vars = c("listpair", "condvar"), value.name = "cin.u")
psi <- reshape2::melt(psinhatcond$psi, id.vars = c("listpair", "condvar"), value.name = "psi")%>% separate(variable, c("model", "method"))
require(tidyr)
psi <- reshape2::melt(psinhatcond$psi, id.vars = c("listpair", "condvar"), value.name = "psi")%>% separate(variable, c("model", "method"))
sigma2 <- reshape2::melt(psinhatcond$sigma2, id.vars = c("listpair", "condvar"), value.name = "sigma2")%>% separate(variable, c("model", "method"))
n <- reshape2::melt(psinhatcond$n, id.vars = c("listpair", "condvar"), value.name = "n")%>% separate(variable, c("model", "method"))
varn <- reshape2::melt(psinhatcond$varn, id.vars = c("listpair", "condvar"), value.name = "varn")%>% separate(variable, c("model", "method"))
N <- psinhatcond$N
cin.l <- reshape2::melt(psinhatcond$cin.l, id.vars = c("listpair", "condvar"), value.name = "cin.l")%>% separate(variable, c("model", "method"))
cin.u <- reshape2::melt(psinhatcond$cin.u, id.vars = c("listpair", "condvar"), value.name = "cin.u")%>% separate(variable, c("model", "method"))
ggplot() +
geom_point(n, aes(x = condvar, y = n, color = method)) +
geom_point(cin.l, aes(x = condvar, y = n, color = method), shape = 24) +
geom_point(cin.u, aes(x = condvar, y = n, color = method), shape = 24) +
facet_wrap(~model)
require(ggplot2)
require(reshape2)
ggplot() +
geom_point(n, aes(x = condvar, y = n, color = method)) +
geom_point(cin.l, aes(x = condvar, y = n, color = method), shape = 24) +
geom_point(cin.u, aes(x = condvar, y = n, color = method), shape = 24) +
facet_wrap(~model)
ggplot() +
geom_point(n, aes(x = condvar, y = n, color = method)) +
geom_point(cin.l, aes(x = condvar, y = n, color = method), shape = 24) +
geom_point(cin.u, aes(x = condvar, y = n, color = method), shape = 24) +
#facet_wrap(~model)
theme_bw()
ggplot(psi) +
geom_point(n, aes(x = condvar, y = n, color = method)) +
geom_point(cin.l, aes(x = condvar, y = n, color = method), shape = 24) +
geom_point(cin.u, aes(x = condvar, y = n, color = method), shape = 24) +
#facet_wrap(~model)
theme_bw()
ggplot(psi) +
geom_point(n, aes(x = condvar, y = n, color = method)) +
geom_point(cin.l, aes(x = condvar, y = n, color = method, shape = 24)) +
geom_point(cin.u, aes(x = condvar, y = n, color = method, shape = 24)) +
#facet_wrap(~model)
theme_bw()
ggplot(n) +
geom_point(n, aes(x = condvar, y = n, color = method)) +
#geom_point(cin.l, aes(x = condvar, y = n, color = method, shape = 24)) +
#geom_point(cin.u, aes(x = condvar, y = n, color = method, shape = 24)) +
#facet_wrap(~model)
theme_bw()
rlang::last_error()
rlang::last_trace()
head(n)
ggplot(n) +
geom_point(aes(x = condvar, y = n, color = method)) +
#geom_point(cin.l, aes(x = condvar, y = n, color = method, shape = 24)) +
#geom_point(cin.u, aes(x = condvar, y = n, color = method, shape = 24)) +
#facet_wrap(~model)
theme_bw()
result<- merge(psi, sigma2, by = c("list_pair", "condvar", "model", "method"))
result<- merge(psi, sigma2, by = c("listpair", "condvar", "model", "method"))
head(result)
result<- merge(psi, sigma2, by = c("listpair", "condvar", "model", "method")) %>%
merge(n, by = c("listpair", "condvar", "model", "method")) %>%
merge(varn, by = c("listpair", "condvar", "model", "method")) %>%
merge(cin.l, by = c("listpair", "condvar", "model", "method")) %>%
merge(cin.u, by = c("listpair", "condvar", "model", "method"))  %>%
merge(N, by = "condvar")
head(result)
ggplot(result) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_point(aes(x = condvar, y = n, color = method, shape = 24)) +
geom_point(aes(x = condvar, y = n, color = method, shape = 24)) +
facet_wrap(~model)
ggplot(result) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_point(aes(x = condvar, y = n, color = method)) +
facet_wrap(~model)
ggplot(result) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_point(aes(x = condvar, y = n, color = method)) +
facet_wrap(~model) +
theme_bw()
ggplot(result) +
geom_point(aes(x = condvar, y = n, color = method)) +
geom_line(aes(x = condvar, y = n, color = method)) +
geom_line(aes(x = condvar, y = n, color = method)) +
facet_wrap(~model) +
theme_bw()
?geom_errorbar
ggplot(result, aes(x = condvar, color = method)) +
geom_point(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u, size = 2)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u, size = 1)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_point(aes(y = n))
+
geom_errorbar(aes(ymin = cin.l, ymax = cin.u)) +
facet_wrap(~model) +
theme_bw()
ggplot(result, aes(x = condvar, color = method)) +
geom_line(aes(y = n)) +
geom_point(aes(y = n)) +
geom_errorbar(aes(ymin = cin.l, ymax = cin.u)) +
facet_wrap(~model) +
theme_bw()

cat("Overlap between the lists", i, "and", j, "is less than", eps, "\n")
}
}
}
}
return(list(#psiinvmat = psiinvmat, varmat = varmat,
psiinv_pi = psiinv_pi, psiinv_bc = psiinv_bc, psiinv_tmle = psiinv_tmle,
phi_pi = phi_bc, phi_bc = phi_bc, phi_tmle = phi_tmle
))
}
phihat_risk = function(List1, List2, K = 2, i = 1, j = 2, func = "logit", nfolds = 2, twolist = TRUE, eps = 0.05, iter = 50, risk_alpha = 1, risk_min = NA, risk_max = NA, length = length){
l = ncol(List1) - K
conforminglists = apply(List1[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
print("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
cat("Lists ", which(conforminglists == FALSE), " are not in the required format.\n")
}
risk_alpha_min = max(min(risk_alpha, 1/risk_alpha), risk_min, na.rm = TRUE)
risk_alpha_max = min(max(risk_alpha, 1/risk_alpha), risk_max, na.rm = TRUE)
delta_vec = unique(seq(risk_alpha_min, risk_alpha_max, length.out = length))
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''))
colnames(List2 = colnames(List1))
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
for(delta in delta_vec){
psiinv_summary[paste(i, ", ", j, sep = ''),] = (delta*q1 + (1 - delta)*q12)*q2/q12
var_summary[paste(i, ", ", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
}
}else{
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
colnames(List2) = colnames(List1)
psiinv_pi = matrix(0, ncol = length(delta_vec), nrow = 1)
colnames(psiinv_pi) = delta_vec
psiinv_bc = psiinv_pi
psiinv_tmle = psiinv_pi
phi_bc = matrix(0, ncol = length(delta_vec), nrow = nrow(List2))
colnames(phi_bc) = colnames(psiinv_pi)
phi_tmle = phi_bc
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
if (class(qhat) == "try-error") {
return(class(qhat))
}
for(coli in 1:length(delta_vec)){
delta = delta_vec[coli]
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(Qnphihat, 1)
psiinv_pi[,coli] = psiinvhat
psiinv_bc[,coli] = psiinvhatq
#print(c(psiinvhat, psiinvhatq))
phi_bc[,coli] = phihat
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12, yi*(1 - yj), yj*(1 - yi)))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12", "yi0", "y0j")
epsilon_error = 1
cnt = 0
while (abs(epsilon_error) > 0.00001){
cnt = cnt + 1
datmat_old = datmat
if (cnt > iter){break}
########################### model 1 for q12
dat1 = cbind(datmat$yij, logit(datmat$q12), delta*(datmat$q10 + datmat$q12)/datmat$q12
+ delta*(datmat$q02 + datmat$q12)/datmat$q12
- delta*(datmat$q10 + datmat$q12)*(datmat$q02 + datmat$q12)/datmat$q12^2 + 1 - delta)
colnames(dat1) = c("yij", "logitq12", "ratio")
dat1 = as.data.frame(dat1)
mod1 = try(glm(yij ~ -1 + offset(logitq12) + ratio
, family = binomial(link = logit), data = dat1, na.action = na.omit))
if (class(mod1) != "try-error"){
datmat[,"q12"] = predict(mod1, newdata = dat1, type = "response")
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q12 = pmax(pmin(datmat$q12, 1), eps)
########################### model 2 for q1
dat2 = cbind(datmat$yi0, logit(datmat$q10), delta*(datmat$q02 + datmat$q12)/datmat$q12)
colnames(dat2) = c("yi0", "logitq10", "ratio")
dat2 = as.data.frame(dat2)
mod2 = try(glm(yi0 ~ -1 + offset(logitq10) + ratio, family = binomial(link = logit), data = dat2, na.action = na.omit))
if (class(mod2) != "try-error"){
datmat$q10 = predict(mod2, newdata = dat2, type = "response")
datmat[,"q10"] = pmin(datmat[,"q10"], 1 - datmat$q12)
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q10 = pmax(pmin(datmat$q10, 1), eps)
########################### model 3 for q2
if (K > 2 | twolist == FALSE){
dat3 = cbind(datmat$y0j, logit(datmat$q02), delta*(datmat$q10 + datmat$q12)/datmat$q12 + 1 - delta)
colnames(dat3) = c("y0j", "logitq02", "ratio")
dat3 = as.data.frame(dat3)
mod3 = try(glm(y0j ~ -1 + offset(logitq02) + ratio, family = binomial(link = logit), data = dat3, na.action = na.omit))
if (class(mod3) != "try-error"){
datmat$q02 = predict(mod3, newdata = dat3, type = "response")
datmat[,"q02"] = pmin(datmat[,"q02"], 1 - datmat$q10 - datmat$q12)
}
}else{
mod3 = mod2
datmat[,"q02"] = pmax(0, 1 - datmat$q10 - datmat$q12)
}
datmat$q02 = pmax(pmin(datmat$q02, 1), eps)
epsilon_error = max(abs(c(mod2$coefficients, mod3$coefficients, mod1$coefficients)))
}
if(epsilon_error > 1){
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinv_tmle[,coli] = psiinvhat
phi_tmle[,coli] = phihat
}
}
}else{
cat("Overlap between the lists", i, "and", j, "is less than", eps, "\n")
}
}
return(list(#psiinvmat = psiinvmat, varmat = varmat,
psiinv_pi = psiinv_pi, psiinv_bc = psiinv_bc, psiinv_tmle = psiinv_tmle,
phi_pi = phi_bc, phi_bc = phi_bc, phi_tmle = phi_tmle
))
}
estim_multi_risk = function(List_matrix, K, l, beta_vec, func = "logit", risk_alpha = 1, i = i, j = j, length = 10, actual = FALSE, alpha = alpha, sigma = sigma, risk_min = NA, risk_max = NA){
n = nrow(List_matrix)
if(missing(K)){
K = ncol(List_matrix) - 1
}
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
pp = phihat_risk(List1, List2, K = K, func = func, i = i, j = j, risk_alpha = risk_alpha, risk_min = risk_min, risk_max = risk_max, length = length)
if(class(pp) == "try-error"){
print("did not run")
return(class(pp))
}
psi_pi = 1/pp$psiinv_pi
psi_bc = 1/pp$psiinv_bc
psi_tmle = 1/pp$psiinv_tmle
sigma2_pi = apply(pp$phi_pi, 2, var)
sigma2_bc = apply(pp$phi_bc, 2, var)
sigma2_tmle = apply(pp$phi_tmle, 2, var)
psimat = cbind(t(psi_pi), t(psi_bc), t(psi_tmle))
rownames(psimat) = colnames(psi_pi)
colnames(psimat) = c("PI", "BC", "TMLE")
sigma2mat = cbind(sigma2_pi, sigma2_bc, sigma2_tmle)
rownames(sigma2mat) = colnames(psi_pi)
colnames(sigma2mat) = c("PI", "BC", "TMLE")
nmat = N/psimat
sigma2n = N*(sigma2mat + (1 - psimat)/psimat)
return(list(psimat = psimat, sigma2mat = sigma2mat, nmat = nmat, sigma2n = sigma2n,
N = N))
}
estim_multi = function(List_matrix, K, l, beta_vec, func = "logit", risk_alpha = 1, i = 3, j = 4, length = 10, actual = FALSE, alpha = alpha, sigma = sigma){
n = nrow(List_matrix)
if(missing(K)){
K = ncol(List_matrix) - 1
}
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
if(missing(risk_alpha)){
pp = phihat(List1, List2, K = K, func = func)
}else{
pp = phihat_risk(List1, List2, K = K, func = func, i = 3, j = 4, risk_alpha = risk_alpha, length = length)
}
psi_pi = 1/pp$psiinv_pi
psi_bc = 1/pp$psiinv_bc
psi_tmle = 1/pp$psiinv_tmle
phi_pi = pp$phi_pi
phi_bc = pp$phi_bc
phi_tmle = pp$phi_tmle
covmatrix_pi = cov(phi_pi)
covmatrix_bc = cov(phi_bc)
covmatrix_tmle = cov(phi_tmle)
psisf = matrix(NA, ncol = 6, nrow = length(beta_vec))
rownames(psisf) = beta_vec
colnames(psisf) = paste(rep(c("PI", "BC", "TMLE"), each = 2), c('u', 'l'))
sigma2sf = psisf
psisf[, "PI u"] = sapply(-beta_vec, function(beta) return(softmax(psi_pi, covmatrix_pi, beta)$xsf))
psisf[, "PI l"] = sapply(beta_vec, function(beta) return(softmax(psi_pi, covmatrix_pi, beta)$xsf))
psisf[, "BC u"] = sapply(-beta_vec, function(beta) return(softmax(psi_bc, covmatrix_bc, beta)$xsf))
psisf[, "BC l"] = sapply(beta_vec, function(beta) return(softmax(psi_bc, covmatrix_bc, beta)$xsf))
psisf[, "TMLE u"] = sapply(-beta_vec, function(beta) return(softmax(psi_tmle, covmatrix_tmle, beta)$xsf))
psisf[, "TMLE l"] = sapply(beta_vec, function(beta) return(softmax(psi_tmle, covmatrix_tmle, beta)$xsf))
psisf = pmax(pmin(psisf, 1), 0)
sigma2sf[, "PI u"] = sapply(-beta_vec, function(beta) return(softmax(psi_pi, covmatrix_pi, beta)$covxsf))
sigma2sf[, "PI l"] = sapply(beta_vec, function(beta) return(softmax(psi_pi, covmatrix_pi, beta)$covxsf))
sigma2sf[, "BC u"] = sapply(-beta_vec, function(beta) return(softmax(psi_bc, covmatrix_bc, beta)$covxsf))
sigma2sf[, "BC l"] = sapply(beta_vec, function(beta) return(softmax(psi_bc, covmatrix_bc, beta)$covxsf))
sigma2sf[, "TMLE u"] = sapply(-beta_vec, function(beta) return(softmax(psi_tmle, covmatrix_tmle, beta)$covxsf))
sigma2sf[, "TMLE l"] = sapply(beta_vec, function(beta) return(softmax(psi_tmle, covmatrix_tmle, beta)$covxsf))
nsf = N/psisf
sigma2nsf = N*(sigma2sf + (1 - psisf)/psisf)
colnames(psisf) = paste(rep(c("PI", "BC", "TMLE"), each = 2), c('l', 'u'))
return(list(psisf = psisf, sigma2sf = sigma2sf, nsf = nsf, sigma2nsf = sigma2nsf,
N = N))
}
normq = function(alpha, mu = 0, sigma = 1, D) {
quant_vec = seq(-3, 3, length.out = 100)
coverage_vec = sapply(quant_vec, function(q){pnorm(D + q) - pnorm(-q)})
if(length(coverage_vec) > 0){
return(quant_vec[which.min(abs(coverage_vec - alpha))])
} else{
return(0)
}
}
# data table to store the estimated values
pestim = numeric(0)
for(n0 in n_vec){print(n0)
for(s in 1:300){print(s)
#print(s)
################## generating data and calculating psi, n estimates
datap = dat_p_K(n0, K, l)
List_matrix = datap$List_matrix_xstar
#       List_matrix = List_matrix[colSums(List_matrix[,1:K])>0,]
estim = estim_multi_risk(List_matrix, K, l, beta_vec, actual = FALSE, func = func, risk_alpha = risk_alpha, i = 1, j = 2, risk_min = risk_min, risk_max = risk_max, alpha = alpha, sigma = sigma, length = length)
p1 = melt(estim$psimat, value.name = "psi")
p2 = melt(estim$sigma2mat, value.name = "sigma2")
p3 = melt(estim$nmat, value.name = "n")
p4 = melt(estim$sigma2n, value.name = "sigma2n")
pall = merge(p1, merge(p2, merge(p3, p4, by = c("Var1", "Var2")), by = c("Var1", "Var2")), by = c("Var1", "Var2"))
colnames(pall)[1:2] = c("delta", "model")
pall$n0 = n0
pall$N = estim$N
pestim = rbind(pestim, pall)
}
beep(sound = 10)
print(summary(pall))
}
#print(s)
################## generating data and calculating psi, n estimates
datap = dat_p_K(n0, K, l)
List_matrix = datap$List_matrix_xstar
#       List_matrix = List_matrix[colSums(List_matrix[,1:K])>0,]
estim = estim_multi_risk(List_matrix, K, l, beta_vec, actual = FALSE, func = func, risk_alpha = risk_alpha, i = 1, j = 2, risk_min = risk_min, risk_max = risk_max, alpha = alpha, sigma = sigma, length = length)
n = nrow(List_matrix)
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
pp = phihat_risk(List1, List2, K = K, func = func, i = i, j = j, risk_alpha = risk_alpha, risk_min = risk_min, risk_max = risk_max, length = length)
class(pp)
pp
l = ncol(List1) - K
conforminglists = apply(List1[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
print("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
cat("Lists ", which(conforminglists == FALSE), " are not in the required format.\n")
}
risk_alpha_min = max(min(risk_alpha, 1/risk_alpha), risk_min, na.rm = TRUE)
risk_alpha_max = min(max(risk_alpha, 1/risk_alpha), risk_max, na.rm = TRUE)
delta_vec = unique(seq(risk_alpha_min, risk_alpha_max, length.out = length))
delta_vec
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
colnames(List2) = colnames(List1)
psiinv_pi = matrix(0, ncol = length(delta_vec), nrow = 1)
colnames(psiinv_pi) = delta_vec
psiinv_bc = psiinv_pi
psiinv_tmle = psiinv_pi
phi_bc = matrix(0, ncol = length(delta_vec), nrow = nrow(List2))
colnames(phi_bc) = colnames(psiinv_pi)
phi_tmle = phi_bc
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
class(qhat)
qhat_sl()
qhat_sl
slib = c("SL.glm"
, "SL.gam"
, "SL.glm.interaction"
)
slib1 = c("SL.glmnet"
,"SL.ranger"
#, "SL.gbm"
)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)) ,
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)) )
fiti = try(SuperLearner::SuperLearner(Y = as.numeric(List1[,i]),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner::SuperLearner(Y = as.numeric(List1[,j]),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner::SuperLearner(Y = as.numeric(pmin(List1[,i], List1[,j])),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fiti
class(fiti)
class(fitj)
class(fitij)
qhat_sl = function(List1, List2, K, i, j, eps){
require("SuperLearner")
require("glmnet")
require("gam")
require("ranger")
require("rpart")
slib = c("SL.glm"
, "SL.gam"
, "SL.glm.interaction"
)
slib1 = c("SL.glmnet"
,"SL.ranger"
#, "SL.gbm"
)
slib2 <- c(slib1, slib,
split(rbind(slib,"screen.corP"),
rep(1:length(slib),each=2)) ,
split(rbind(slib,"screen.glmnet"),
rep(1:length(slib),each=2)) )
#suppressWarnings()
fiti = try(SuperLearner(Y = as.numeric(List1[,i]),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitj = try(SuperLearner(Y = as.numeric(List1[,j]),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
fitij = try(SuperLearner(Y = as.numeric(pmin(List1[,i], List1[,j])),
X = as.data.frame(List1[,-c(1:K)]),
family = binomial(), SL.library = slib2, verbose = FALSE), silent = TRUE)
if("try_error" %in% c(class(fiti), class(fitj), class(fitij))){
Warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}else{
q12 = pmax(pmin(
predict(fitij, newdata = List2[,-c(1:K)], onlySL = TRUE)$pred, 1), eps)
q1 = pmin(pmax(
predict(fiti, newdata = List2[,-c(1:K)], onlySL = TRUE)$pred, q12), 1)
q2 = pmin(pmax(
predict(fitj, newdata = List2[,-c(1:K)], onlySL = TRUE)$pred, q12), 1)
}
return(list(q1 = q1, q2 = q2, q12 = q12))
}
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
L
K
i
j
eps
eps = 0.05
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
class(qhat)
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = get(paste0("qhat_", func))(List1, List2, K, i, j, eps)
func
func = "sl"
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = get(paste0("qhat_", func))(List1, List2, K, i, j, eps)
class(qhat)
library(reshape2)
library(ggplot2)
library(dplyr)
library(ggpubr)
library(glue)
library(colorspace)
library(beepr)
n0 = 5000
K = 2
l = 3
source("C:/Users/manja/Dropbox/capture_recapture/codes/multi_list/simulation_multi_list_risk.R")
#source("C:/Users/manja/Dropbox/capture_recapture/codes/multi_list/functions_multi_psi_theta_new_notation.R")
source("C:/Users/manja/Dropbox/capture_recapture/codes/multi_list/functions_multilist2.R")
func = "sl"
length = 15
risk_alpha = 1.5
risk_min = 0.5
risk_max = 1.125
#n_vec= c(1000, 5000, 10000, 15000, 20000)
#n_vec= c(25000, 30000, 35000, 40000, 45000)
n_vec = 5000#c(1:3)*1000
psi0
cvrgprob_vec = c(0.95)
# data table to store the estimated values
pestim = numeric(0)
for(n0 in n_vec){print(n0)
for(s in 1:300){print(s)
#print(s)
################## generating data and calculating psi, n estimates
datap = dat_p_K(n0, K, l)
List_matrix = datap$List_matrix_xstar
#       List_matrix = List_matrix[colSums(List_matrix[,1:K])>0,]
estim = estim_multi_risk(List_matrix, K, l, beta_vec, actual = FALSE, func = func, risk_alpha = risk_alpha, i = 1, j = 2, risk_min = risk_min, risk_max = risk_max, alpha = alpha, sigma = sigma, length = length)
p1 = melt(estim$psimat, value.name = "psi")
p2 = melt(estim$sigma2mat, value.name = "sigma2")
p3 = melt(estim$nmat, value.name = "n")
p4 = melt(estim$sigma2n, value.name = "sigma2n")
pall = merge(p1, merge(p2, merge(p3, p4, by = c("Var1", "Var2")), by = c("Var1", "Var2")), by = c("Var1", "Var2"))
colnames(pall)[1:2] = c("delta", "model")
pall$n0 = n0
pall$N = estim$N
pestim = rbind(pestim, pall)
}
beep(sound = 10)
print(summary(pall))
}
if(FALSE){
beep(sound = 8)
psi = matrix(NA, nrow = length(beta_vec), ncol = 3)
psi[,1] = beta_vec
colnames(psi) = c("beta", "psi0_l", "psi0_u")
xmat = matrix(rnorm(n0*l, 2, 1), ncol = l)
psi_risk = function(delta){
pmax(pmin(1/mean(apply(xmat, 1, function(x) {
gammax = 1 - (1 - pi1(x))*(1 - pi2(x))*(1 - pi3(x))*(1 - pi4_0(x))
q1 = pi3(x)
q2 = pi3(x)*pi4_1(x) + (1 - pi3(x))*pi4_0(x)
q12 = pi3(x)*pi4_1(x)
return((delta*(q1-q12) + q12)*q2/q12)
})), 1), 0)
}
psi[,"psi0_u"] = psi_risk(1/risk_alpha)
psi[,"psi0_l"] = psi_risk(risk_alpha)
pestim = merge(pestim, psi, by = "beta", all.x = TRUE)
}
pc = pestim
pc$psi0 = psi0
pc$biaspsi = abs(pc$psi - pc$psi0)
pc$biasn = abs(pc$n - pc$N/pc$psi0)
pc$varpsi = pc$sigma2/pc$N*pc$psi^4
pc$cvrgpsi = abs(pc$biaspsi) < 1.95*sqrt(pc$varpsi)
pc$cvrgn = abs(pc$biasn) < 1.95*sqrt(pc$sigma2n)
pc$cvrgpsi = (psi0 < pc$psi + 1.95*sqrt(pc$varpsi))*(psi0 > pc$psi - 1.95*sqrt(pc$varpsi))
pc$cvrgn = (pc$n0 < pc$n + 1.95*sqrt(pc$sigma2n))*(pc$n0 > pc$n - 1.95*sqrt(pc$sigma2n))
pc = aggregate(cbind(psi, varpsi, n, sigma2n, biaspsi, biasn, cvrgpsi, cvrgn, psi0)~delta + model + n0, data = pc, mean)
color1 = "red"
color2 = "#E69F00"
color3 = "dodgerblue1" #  "#56B4E9"
lsize = 1
tsize = 16
gbasic = ggplot(pc, aes(x = delta, color = model, fill = model)) +
scale_color_manual(values = c("PI" = color1, "BC" = color2, "TMLE" = color3)) +
scale_fill_manual(values = c("PI" = color1, "BC" = color2, "TMLE" = color3)) +
ylab(NULL) +
facet_wrap(~n0) +
labs(x = "risk_ratio") +
theme_bw() +
theme(text = element_text(size = tsize)) +
theme(legend.position = "bottom", axis.text.x = element_text(angle = 90))
g1 = gbasic + geom_line(aes(y = biasn), size = lsize) +
ggtitle("Bias of n")
g2 = gbasic + geom_line(aes(y = cvrgn), size = lsize) +
ggtitle("Coverage of n")
g3 = gbasic +
geom_line(aes(y = n + 1.95*sqrt(sigma2n)), size = lsize) +
geom_line(aes(y = n - 1.95*sqrt(sigma2n)), size = lsize) +
geom_line(aes(y = n0), linetype = "dashed", color = "black") +
ggtitle('95% CI of n')
g4 = gbasic + geom_line(aes(y = biaspsi), size = lsize) +
ggtitle("Bias of psi")
g5 = gbasic + geom_line(aes(y = cvrgpsi), size = lsize) +
ggtitle("Coverage of psi")
g6 = gbasic +
#  geom_ribbon(data = .%>% filter(variable == "max"), aes(ymin = n0, ymax = n + nq*nsd), alpha = 0.3, show.legend = FALSE) +
#  geom_ribbon(data = .%>% filter(variable == "min"), aes(ymin = n0, ymax = n - nq*nsd), alpha = 0.3, show.legend = FALSE) +
geom_line(aes(y = psi + 1.95*sqrt(varpsi)), size = lsize) +
geom_line(aes(y = psi - 1.95*sqrt(varpsi)), size = lsize) +
geom_line(aes(y = psi0), linetype = "dashed", color = "black") +
#ggtitle(glue("95% CI of psi"))
labs(title = substitute(paste('95% CI of ', psi, ', true ', psi, ' = ', var), list(var = round(psi0, 2))))
ggall = ggarrange(g1, g2, g3, g4, g5, g6, ncol = 3, nrow = 2, common.legend = TRUE, legend = "bottom")
ggall = annotate_figure(ggall, top = text_grob(paste("Summary for capture probability", round(psi0, 2)), size = 15))
ggall
ggall

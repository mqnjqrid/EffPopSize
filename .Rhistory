List_matrix = (datapset)
N = length(which(rowSums(List_matrix[,1:K]) > 0))
if (N >= 5) {
est_val = psinhat(List_matrix, K = K, funcname = funcname, nfolds = nfolds, eps = eps, twolist = FALSE)
#psimat[psimat$situacion == situation & psimat$perpetrator == agent,-c(1:3)][1:nfolds,] = cbind(est_val$psimat, est_val$psimat2)
psiestim[psiestim$situacion == situation & psiestim$perpetrator == agent,5:10] = cbind(n, N, t(est_val$psi), t(est_val$sigma2),
t(est_val$n), t(est_val$varn))
}else{
psiestim[psiestim$situacion == situation & psiestim$perpetrator == agent,5:10] = cbind(n, N, NA, NA, n, 0)
}
}
psibarplot = psiestim
psibarplot$situacion = factor(psibarplot$situacion)
levels(psibarplot$situacion) = list("disappeared"="DES", "dead"="MUE", "combined"="all")
psibarplot$method = factor(psibarplot$method)
levels(psibarplot$method) = list("PI"="PI", "BC"="BC", "TMLE"="TMLE", "BCTMLE"="BCTMLE")
psibarplot$perpetrator = factor(psibarplot$perpetrator)
levels(psibarplot$perpetrator) = list("EST"=1, "SLU"=2, "OTR"=3, "NOD"=4, "Total"=5)
tsize = 12
psibarplot$n_hat = as.numeric(as.character(psibarplot$n_hat))
options(scipen = 5)
tsize = 15
psipibctr = ggplot(psibarplot[psibarplot$perpetrator %in% c("EST", "SLU", "OTR", "NOD", "Total") & psibarplot$method != "BCTMLE",], aes(x = perpetrator, y = n_hat, fill = perpetrator)) +
geom_bar(stat = "identity") +
theme_bw() +
ylab("Number of killings") +
#ylim(c(0, NA)) +
scale_fill_manual(name = "Perpetrator", labels = c("State", "PCP-Shining Path", "Others", "Unidentified", "Total"), values = c("EST" = "#56B4E9", "SLU" = "#E69F00", "OTR" = "#999999", "NOD" = "lightgreen", "Total" = "lightcoral")) +
facet_grid(situacion~method + model, scales = "free_y", labeller=label_wrap_gen(width = 10, multi_line = FALSE)) +
geom_errorbar(aes(ymin = pmax(n_hat - 1.95*sqrt(varn), n), ymax = n_hat + 1.95*sqrt(varn)), size = 0.5) +
theme(text = element_text(size = tsize), axis.text.x = element_blank(), axis.ticks.x=element_blank(), axis.title.x=element_blank(), legend.position = "bottom")
psipibctr
library(profvis)
p1 = profvis({
phihat_risk = function(List1, List2, K = 2, i = 1, j = 2, func = "logit", nfolds = 2, twolist = FALSE, eps = 0.005, iter = 50, risk_alpha = 1, length = length){
l = ncol(List1) - K
conforminglists = apply(List1[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
print("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
cat("Lists ", which(conforminglists == FALSE), " are not in the required format.\n")
}
delta_vec = unique(seq(risk_alpha, 1/risk_alpha, length.out = length))
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''))
colnames(List2 = colnames(List1))
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
for(delta in delta_vec){
psiinv_summary[paste(i, ", ", j, sep = ''),] = (delta*q1 + (1 - delta)*q12)*q2/q12
var_summary[paste(i, ", ", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
}
}else{
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
colnames(List2) = colnames(List1)
psiinv_pi = matrix(0, ncol = length(delta_vec), nrow = 1)
colnames(psiinv_pi) = delta_vec
psiinv_bc = psiinv_pi
psiinv_tmle = psiinv_pi
phi_bc = matrix(0, ncol = length(delta_vec), nrow = nrow(List2))
colnames(phi_bc) = colnames(psiinv_pi)
phi_tmle = phi_bc
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
if (class(qhat) == "try-error") {
next
}
for(delta in delta_vec){
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(Qnphihat, 1)
psiinv_pi[,delta] = psiinvhat
psiinv_bc[,delta] = psiinvhatq
phi_bc[,delta] = phihat
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12, yi*(1 - yj), yj*(1 - yi)))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12", "yi0", "y0j")
epsilon_error = 1
cnt = 0
while (abs(epsilon_error) > 0.00001){
cnt = cnt + 1
datmat_old = datmat
if (cnt > iter){break}
########################### model 1 for q12
dat1 = cbind(datmat$yij, logit(datmat$q12), delta*(datmat$q10 + datmat$q12)/datmat$q12
+ delta+(datmat$q02 + datmat$q12)/datmat$q12
- delta*(datmat$q10 + datmat$q12)*(datmat$q02 + datmat$q12)/datmat$q12^2 + 1 - delta)
colnames(dat1) = c("yij", "logitq12", "ratio")
dat1 = as.data.frame(dat1)
mod1 = try(glm(yij ~ -1 + offset(logitq12) + ratio
, family = binomial(link = logit), data = dat1, na.action = na.omit))
if (class(mod1) != "try-error"){
datmat[,"q12"] = predict(mod1, newdata = dat1, type = "response")
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q12 = pmax(pmin(datmat$q12, 1), eps)
########################### model 2 for q1
dat2 = cbind(datmat$yi0, logit(datmat$q10), delta*(datmat$q02 + datmat$q12)/datmat$q12)
colnames(dat2) = c("yi0", "logitq10", "ratio")
dat2 = as.data.frame(dat2)
mod2 = try(glm(yi0 ~ -1 + offset(logitq10) + ratio, family = binomial(link = logit), data = dat2, na.action = na.omit))
if (class(mod2) != "try-error"){
datmat$q10 = predict(mod2, newdata = dat2, type = "response")
datmat[,"q10"] = pmin(datmat[,"q10"], 1 - datmat$q12)
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q10 = pmax(pmin(datmat$q10, 1), eps)
########################### model 3 for q2
if (K > 2 | twolist == FALSE){
dat3 = cbind(datmat$y0j, logit(datmat$q02), delta*(datmat$q10 + datmat$q12)/datmat$q12 + 1 - delta)
colnames(dat3) = c("y0j", "logitq02", "ratio")
dat3 = as.data.frame(dat3)
mod3 = try(glm(y0j ~ -1 + offset(logitq02) + ratio, family = binomial(link = logit), data = dat3, na.action = na.omit))
if (class(mod3) != "try-error"){
datmat$q02 = predict(mod3, newdata = dat3, type = "response")
datmat[,"q02"] = pmin(datmat[,"q02"], 1 - datmat$q10 - datmat$q12)
}
}else{
mod3 = mod2
datmat[,"q02"] = pmax(0, 1 - datmat$q10 - datmat$q12)
}
datmat$q02 = pmax(pmin(datmat$q02, 1), eps)
epsilon_error = max(abs(c(mod2$coefficients, mod3$coefficients, mod1$coefficients)))
}
if(epsilon_error > 1){
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinv_tmle[,delta] = psiinvhat
phi_tmle[,delta] = phihat
}
}
}else{
cat("Overlap between the lists", i, "and", j, "is less than", eps, "\n")
}
}
return(list(#psiinvmat = psiinvmat, varmat = varmat,
psiinv_pi = psiinv_pi, psiinv_bc = psiinv_bc, psiinv_tmle = psiinv_tmle,
phi_pi = phi_bc, phi_bc = phi_bc, phi_tmle = phi_tmle
))
}
estim_multi_risk = function(List_matrix, K, l, beta_vec, func = "logit", risk_alpha = 1, i = 3, j = 4, length = 10, actual = FALSE, alpha = alpha, sigma = sigma){
n = nrow(List_matrix)
if(missing(K)){
K = ncol(List_matrix) - 1
}
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
pp = phihat_risk(List1, List2, K = K, func = func, i = 3, j = 4, risk_alpha = risk_alpha, length = length)
psi_pi = 1/pp$psiinv_pi
psi_bc = 1/pp$psiinv_bc
psi_tmle = 1/pp$psiinv_tmle
sigma2_pi = apply(pp$phi_pi, 2, var)
sigma2_bc = apply(pp$phi_bc, 2, var)
sigma2_tmle = apply(pp$phi_tmle, 2, var)
psimat = cbind(t(psi_pi), t(psi_bc), t(psi_tmle))
rownames(psimat) = colnames(psi_pi)
colnames(psimat) = c("PI", "BC", "TMLE")
sigma2mat = cbind(sigma2_pi, sigma2_bc, sigma2_tmle)
rownames(sigma2mat) = colnames(psi_pi)
colnames(sigma2mat) = c("PI", "BC", "TMLE")
nmat = N/psimat
sigma2n = N*(sigma2mat + (1 - psimat)/psimat)
return(list(psimat = psimat, sigma2mat = sigma2mat, nmat = nmat, sigma2n = sigma2n,
N = N))
}
})
p1 = profvis({
phihat_risk = function(List1, List2, K = 2, i = 1, j = 2, func = "logit", nfolds = 2, twolist = FALSE, eps = 0.005, iter = 50, risk_alpha = 1, length = length){
l = ncol(List1) - K
conforminglists = apply(List1[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
print("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
cat("Lists ", which(conforminglists == FALSE), " are not in the required format.\n")
}
delta_vec = unique(seq(risk_alpha, 1/risk_alpha, length.out = length))
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''))
colnames(List2 = colnames(List1))
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
for(delta in delta_vec){
psiinv_summary[paste(i, ", ", j, sep = ''),] = (delta*q1 + (1 - delta)*q12)*q2/q12
var_summary[paste(i, ", ", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
}
}else{
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
colnames(List2) = colnames(List1)
psiinv_pi = matrix(0, ncol = length(delta_vec), nrow = 1)
colnames(psiinv_pi) = delta_vec
psiinv_bc = psiinv_pi
psiinv_tmle = psiinv_pi
phi_bc = matrix(0, ncol = length(delta_vec), nrow = nrow(List2))
colnames(phi_bc) = colnames(psiinv_pi)
phi_tmle = phi_bc
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
if (class(qhat) == "try-error") {
next
}
for(delta in delta_vec){
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(Qnphihat, 1)
psiinv_pi[,delta] = psiinvhat
psiinv_bc[,delta] = psiinvhatq
phi_bc[,delta] = phihat
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12, yi*(1 - yj), yj*(1 - yi)))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12", "yi0", "y0j")
epsilon_error = 1
cnt = 0
while (abs(epsilon_error) > 0.00001){
cnt = cnt + 1
datmat_old = datmat
if (cnt > iter){break}
########################### model 1 for q12
dat1 = cbind(datmat$yij, logit(datmat$q12), delta*(datmat$q10 + datmat$q12)/datmat$q12
+ delta+(datmat$q02 + datmat$q12)/datmat$q12
- delta*(datmat$q10 + datmat$q12)*(datmat$q02 + datmat$q12)/datmat$q12^2 + 1 - delta)
colnames(dat1) = c("yij", "logitq12", "ratio")
dat1 = as.data.frame(dat1)
mod1 = try(glm(yij ~ -1 + offset(logitq12) + ratio
, family = binomial(link = logit), data = dat1, na.action = na.omit))
if (class(mod1) != "try-error"){
datmat[,"q12"] = predict(mod1, newdata = dat1, type = "response")
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q12 = pmax(pmin(datmat$q12, 1), eps)
########################### model 2 for q1
dat2 = cbind(datmat$yi0, logit(datmat$q10), delta*(datmat$q02 + datmat$q12)/datmat$q12)
colnames(dat2) = c("yi0", "logitq10", "ratio")
dat2 = as.data.frame(dat2)
mod2 = try(glm(yi0 ~ -1 + offset(logitq10) + ratio, family = binomial(link = logit), data = dat2, na.action = na.omit))
if (class(mod2) != "try-error"){
datmat$q10 = predict(mod2, newdata = dat2, type = "response")
datmat[,"q10"] = pmin(datmat[,"q10"], 1 - datmat$q12)
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q10 = pmax(pmin(datmat$q10, 1), eps)
########################### model 3 for q2
if (K > 2 | twolist == FALSE){
dat3 = cbind(datmat$y0j, logit(datmat$q02), delta*(datmat$q10 + datmat$q12)/datmat$q12 + 1 - delta)
colnames(dat3) = c("y0j", "logitq02", "ratio")
dat3 = as.data.frame(dat3)
mod3 = try(glm(y0j ~ -1 + offset(logitq02) + ratio, family = binomial(link = logit), data = dat3, na.action = na.omit))
if (class(mod3) != "try-error"){
datmat$q02 = predict(mod3, newdata = dat3, type = "response")
datmat[,"q02"] = pmin(datmat[,"q02"], 1 - datmat$q10 - datmat$q12)
}
}else{
mod3 = mod2
datmat[,"q02"] = pmax(0, 1 - datmat$q10 - datmat$q12)
}
datmat$q02 = pmax(pmin(datmat$q02, 1), eps)
epsilon_error = max(abs(c(mod2$coefficients, mod3$coefficients, mod1$coefficients)))
}
if(epsilon_error > 1){
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinv_tmle[,delta] = psiinvhat
phi_tmle[,delta] = phihat
}
}
}else{
cat("Overlap between the lists", i, "and", j, "is less than", eps, "\n")
}
}
return(list(#psiinvmat = psiinvmat, varmat = varmat,
psiinv_pi = psiinv_pi, psiinv_bc = psiinv_bc, psiinv_tmle = psiinv_tmle,
phi_pi = phi_bc, phi_bc = phi_bc, phi_tmle = phi_tmle
))
}
K = 4; l = 3; func = "logit"; risk_alpha = 1; i = 3; j = 4; length = 10
n = nrow(List_matrix)
if(missing(K)){
K = ncol(List_matrix) - 1
}
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
pp = phihat_risk(List1, List2, K = K, func = func, i = 3, j = 4, risk_alpha = risk_alpha, length = length)
psi_pi = 1/pp$psiinv_pi
psi_bc = 1/pp$psiinv_bc
psi_tmle = 1/pp$psiinv_tmle
sigma2_pi = apply(pp$phi_pi, 2, var)
sigma2_bc = apply(pp$phi_bc, 2, var)
sigma2_tmle = apply(pp$phi_tmle, 2, var)
psimat = cbind(t(psi_pi), t(psi_bc), t(psi_tmle))
rownames(psimat) = colnames(psi_pi)
colnames(psimat) = c("PI", "BC", "TMLE")
sigma2mat = cbind(sigma2_pi, sigma2_bc, sigma2_tmle)
rownames(sigma2mat) = colnames(psi_pi)
colnames(sigma2mat) = c("PI", "BC", "TMLE")
nmat = N/psimat
sigma2n = N*(sigma2mat + (1 - psimat)/psimat)
})
p1
p1 = profvis({
l = ncol(List1) - K
conforminglists = apply(List1[,1:K], 2, function(col){return(setequal(col, c(0,1)))})
if(sum(conforminglists) < 2){
print("Data is not in the required format or lists are degenerate.")
return(NULL)
}
if(sum(conforminglists) < K){
cat("Lists ", which(conforminglists == FALSE), " are not in the required format.\n")
}
delta_vec = unique(seq(risk_alpha, 1/risk_alpha, length.out = length))
if(l == 0){
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''))
colnames(List2 = colnames(List1))
q1 = mean(List_matrix[,i])
q2 = mean(List_matrix[,j])
q12 = mean(List_matrix[,i]*List_matrix[,j])
for(delta in delta_vec){
psiinv_summary[paste(i, ", ", j, sep = ''),] = (delta*q1 + (1 - delta)*q12)*q2/q12
var_summary[paste(i, ", ", j, sep = ''),] = q1*q2*(q1*q2 - q12)*(1 - q12)/q12^3/N
}
}else{
#renaming the columns of List_matrix for ease of use
colnames(List1) = c(paste("L", 1:K, sep = ''), paste("x", 1:(ncol(List_matrix) - K), sep = ''))
colnames(List2) = colnames(List1)
psiinv_pi = matrix(0, ncol = length(delta_vec), nrow = 1)
colnames(psiinv_pi) = delta_vec
psiinv_bc = psiinv_pi
psiinv_tmle = psiinv_pi
phi_bc = matrix(0, ncol = length(delta_vec), nrow = nrow(List2))
colnames(phi_bc) = colnames(psiinv_pi)
phi_tmle = phi_bc
yi = List2[,paste("L", i, sep = '')]
yj = List2[,paste("L", j, sep = '')]
if(mean(List1[,i]*List1[,j]) > eps) {
#colsubset = stringr::str_subset(colnames(psiinv_summary), func)
qhat = try(get(paste0("qhat_", func))(List1, List2, K, i, j, eps), silent = TRUE)
if (class(qhat) == "try-error") {
next
}
for(delta in delta_vec){
q12 = qhat$q12
q1 = pmin(pmax(q12, qhat$q1), 1)
q2 = pmax(q12/q1, pmin(qhat$q2, 1 + q12 - q1, 1))
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinvhatq = max(Qnphihat, 1)
psiinv_pi[,delta] = psiinvhat
psiinv_bc[,delta] = psiinvhatq
phi_bc[,delta] = phihat
datmat = as.data.frame(cbind(yi, yj, yi*yj, q1 - q12, q2 - q12, q12, yi*(1 - yj), yj*(1 - yi)))
datmat[,4:6] = cbind(apply(datmat[,4:6], 2, function(u) {return(pmin(pmax(u, eps), 1 - eps))}))
colnames(datmat) = c("yi", "yj", "yij", "q10", "q02", "q12", "yi0", "y0j")
epsilon_error = 1
cnt = 0
while (abs(epsilon_error) > 0.00001){
cnt = cnt + 1
datmat_old = datmat
if (cnt > iter){break}
########################### model 1 for q12
dat1 = cbind(datmat$yij, logit(datmat$q12), delta*(datmat$q10 + datmat$q12)/datmat$q12
+ delta+(datmat$q02 + datmat$q12)/datmat$q12
- delta*(datmat$q10 + datmat$q12)*(datmat$q02 + datmat$q12)/datmat$q12^2 + 1 - delta)
colnames(dat1) = c("yij", "logitq12", "ratio")
dat1 = as.data.frame(dat1)
mod1 = try(glm(yij ~ -1 + offset(logitq12) + ratio
, family = binomial(link = logit), data = dat1, na.action = na.omit))
if (class(mod1) != "try-error"){
datmat[,"q12"] = predict(mod1, newdata = dat1, type = "response")
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q12 = pmax(pmin(datmat$q12, 1), eps)
########################### model 2 for q1
dat2 = cbind(datmat$yi0, logit(datmat$q10), delta*(datmat$q02 + datmat$q12)/datmat$q12)
colnames(dat2) = c("yi0", "logitq10", "ratio")
dat2 = as.data.frame(dat2)
mod2 = try(glm(yi0 ~ -1 + offset(logitq10) + ratio, family = binomial(link = logit), data = dat2, na.action = na.omit))
if (class(mod2) != "try-error"){
datmat$q10 = predict(mod2, newdata = dat2, type = "response")
datmat[,"q10"] = pmin(datmat[,"q10"], 1 - datmat$q12)
}
summary(cbind(datmat[,4:6], datmat_old[,4:6]))
datmat$q10 = pmax(pmin(datmat$q10, 1), eps)
########################### model 3 for q2
if (K > 2 | twolist == FALSE){
dat3 = cbind(datmat$y0j, logit(datmat$q02), delta*(datmat$q10 + datmat$q12)/datmat$q12 + 1 - delta)
colnames(dat3) = c("y0j", "logitq02", "ratio")
dat3 = as.data.frame(dat3)
mod3 = try(glm(y0j ~ -1 + offset(logitq02) + ratio, family = binomial(link = logit), data = dat3, na.action = na.omit))
if (class(mod3) != "try-error"){
datmat$q02 = predict(mod3, newdata = dat3, type = "response")
datmat[,"q02"] = pmin(datmat[,"q02"], 1 - datmat$q10 - datmat$q12)
}
}else{
mod3 = mod2
datmat[,"q02"] = pmax(0, 1 - datmat$q10 - datmat$q12)
}
datmat$q02 = pmax(pmin(datmat$q02, 1), eps)
epsilon_error = max(abs(c(mod2$coefficients, mod3$coefficients, mod1$coefficients)))
}
if(epsilon_error > 1){
psiinvmat[folds,colsubset][3] = NA
varmat[folds,colsubset][3] = NA
}else{
q12 = pmax(datmat$q12, eps)
q1 = pmin(datmat$q12 + datmat$q10, 1)
q2 = pmax(pmin(datmat$q12 + datmat$q02, 1 + q12 - q1, 1), q12/q1)
gammahat = (delta*(q1 - q12) + q12)*q2/q12
psiinvhat = mean(gammahat, na.rm = TRUE)
phihat = gammahat*(yj/q2 + (delta*(yi - yi*yj) + yi*yj)/(delta*(q1 - q12) + q12) - yi*yj/q12)
Qnphihat = mean(phihat, na.rm = TRUE)
psiinv_tmle[,delta] = psiinvhat
phi_tmle[,delta] = phihat
}
}
}else{
cat("Overlap between the lists", i, "and", j, "is less than", eps, "\n")
}
}
K = 4; l = 3; func = "logit"; risk_alpha = 1; i = 3; j = 4; length = 10
n = nrow(List_matrix)
if(missing(K)){
K = ncol(List_matrix) - 1
}
l = ncol(List_matrix) - K
List_matrix = na.omit(List_matrix)
#removing all rows with only 0's
List_matrix_cov = List_matrix[which(rowSums(List_matrix[,1:K]) > 0),]
colnames(List_matrix_cov) = c(paste("L", 1:K, sep = ''), paste("x", 1:l, sep = ''))
#N = number of observed or captured units
N = nrow(List_matrix_cov)
set1 = sample(N, ceiling(N/2), replace = FALSE)
List1 = as.data.frame(List_matrix_cov[set1,])
List2 = as.data.frame(List_matrix_cov[-set1,])
pp = phihat_risk(List1, List2, K = K, func = func, i = 3, j = 4, risk_alpha = risk_alpha, length = length)
psi_pi = 1/pp$psiinv_pi
psi_bc = 1/pp$psiinv_bc
psi_tmle = 1/pp$psiinv_tmle
sigma2_pi = apply(pp$phi_pi, 2, var)
sigma2_bc = apply(pp$phi_bc, 2, var)
sigma2_tmle = apply(pp$phi_tmle, 2, var)
psimat = cbind(t(psi_pi), t(psi_bc), t(psi_tmle))
rownames(psimat) = colnames(psi_pi)
colnames(psimat) = c("PI", "BC", "TMLE")
sigma2mat = cbind(sigma2_pi, sigma2_bc, sigma2_tmle)
rownames(sigma2mat) = colnames(psi_pi)
colnames(sigma2mat) = c("PI", "BC", "TMLE")
nmat = N/psimat
sigma2n = N*(sigma2mat + (1 - psimat)/psimat)
})
p1
fiti0 = try(glm(formula(paste("L", i, "*(1 - L", j, ") ~.", sep = '')), family = binomial(link = "logit"), data = List1[,c(i, j, (K + 1):ncol(List1))]))
i
j
